<!DOCTYPE html>
<html lang="zh-CN">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover">
<title>掼蛋升级计算器 v8.0（玩家系统）</title>
<meta name="theme-color" content="#0b0b0c">
<style>
:root{ --bg:#0b0b0c; --card:#16171b; --ink:#f5f6f8; --muted:#b4b8bf; --stroke:#2a2d35; --chip:#24262c; --accent:#e6b800; }
*{box-sizing:border-box} body{margin:0;background:var(--bg);color:var(--ink);font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,"Helvetica Neue",Arial,"Noto Sans","PingFang SC","Hiragino Sans GB","Microsoft YaHei",sans-serif;-webkit-font-smoothing:antialiased}
.wrap{max-width:1150px;margin:0 auto;padding:16px}
.card{background:var(--card);border-radius:14px;padding:16px;margin:12px 0;box-shadow:0 6px 24px rgba(0,0,0,.25)}
h1{font-size:22px;margin:8px 0 4px} h3{margin:0 0 8px 0}
.small{font-size:12px}.muted{color:var(--muted)} .row{display:flex;gap:10px;flex-wrap:wrap;align-items:center}
input[type=text],input[type=number],input[type=color],select,button{background:#1f2229;color:var(--ink);border:1px solid var(--stroke);border-radius:12px;padding:10px 12px;font-size:16px}
input[type=text]{background:#0f1115;border-radius:10px}
button{cursor:pointer} button:hover{background:#232730}
.badge{display:inline-block;padding:3px 8px;border-radius:999px;background:var(--chip);margin-right:6px}
.counter{font-variant-numeric:tabular-nums}
.grid{display:grid;grid-template-columns:repeat(auto-fit,minmax(260px,1fr));gap:10px}
.gridN{display:grid;gap:8px}
.tile{display:flex;align-items:center;justify-content:center;height:52px;border-radius:12px;background:#24262c;border:1px solid var(--stroke);cursor:pointer;font-size:18px}
.tile.selected{background:#324056;border-color:#3e526b}
.team{display:flex;gap:10px;align-items:center;flex-wrap:wrap}
.team .chip{padding:4px 8px;border-radius:8px;background:#0f1115;border:1px solid var(--stroke)}
.table-wrap{overflow-x:auto;-webkit-overflow-scrolling:touch;border:1px solid var(--stroke);border-radius:10px}
.table{width:100%;border-collapse:separate;border-spacing:0;min-width:900px}
.table th,.table td{border-bottom:1px solid #2a2d35;padding:10px 8px;text-align:left;font-size:14px;white-space:nowrap}
.table th{position:sticky;top:0;background:var(--card);z-index:1}
.actions button{font-size:12px;padding:6px 8px}
.winbtn{position:relative;display:inline-flex;align-items:center;gap:8px;border-width:2px;font-weight:700;overflow:hidden;min-width:96px;transition:transform .08s ease,box-shadow .2s ease,background .15s ease,color .15s ease}
.winbtn:hover{transform:translateY(-1px);box-shadow:0 8px 20px rgba(0,0,0,.28)} .winbtn.active{box-shadow:0 0 0 2px rgba(255,255,255,.08) inset}
.ripple{position:absolute;border-radius:50%;transform:scale(0);opacity:.35;pointer-events:none;animation:ripple .6s ease-out}
@keyframes ripple{to{transform:scale(3);opacity:0}}
@media (max-width:768px){ .wrap{padding:12px} .grid{grid-template-columns:1fr} .gridN .tile{height:48px} #winBtnsWrap .winbtn{flex:1;justify-content:center} .btns-grid{display:grid;grid-template-columns:1fr 1fr;gap:8px} .table{min-width:720px} }
details{background:#131419;border:1px solid var(--stroke);border-radius:12px;padding:10px 12px}
details>summary{cursor:pointer;font-weight:600}
details+details{margin-top:8px}
.toggle{display:inline-flex;align-items:center;gap:6px}

/* Player System Styles */
.player-tile{display:inline-flex;align-items:center;gap:8px;padding:8px 12px;background:#1f2229;border:2px solid var(--stroke);border-radius:10px;cursor:move;user-select:none;-webkit-user-select:none;touch-action:none;transition:all .2s;margin:4px}
.player-tile:hover{transform:translateY(-2px);box-shadow:0 4px 12px rgba(0,0,0,.3)}
.player-tile.dragging{opacity:.5;transform:scale(0.95)}
.player-tile .emoji{font-size:20px}
.player-tile .name{font-size:14px;max-width:100px;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}
.player-tile input{background:transparent;border:none;color:var(--ink);font-size:14px;width:80px;padding:0;touch-action:auto;user-select:text;-webkit-user-select:text}

.team-drop-zone{min-height:80px;background:#0f1115;border:2px dashed var(--stroke);border-radius:12px;padding:12px;margin:8px 0;display:flex;flex-wrap:wrap;gap:8px;transition:all .2s}
.team-drop-zone.drag-over{border-color:var(--accent);background:rgba(230,184,0,.05)}
.team-drop-zone .label{width:100%;font-size:12px;color:var(--muted);margin-bottom:4px}

.rank-slot{display:inline-flex;align-items:center;justify-content:center;min-width:150px;min-height:60px;background:#1f2229;border:2px solid var(--stroke);border-radius:12px;margin:8px;padding:8px;transition:all .2s;position:relative}
.rank-slot.drag-over{border-color:var(--accent);background:rgba(230,184,0,.1)}

/* Touch-specific styles for better mobile UX */
@media (hover: none) and (pointer: coarse) {
  .player-tile, .ranking-player-tile {
    padding: 10px 14px;
    min-height: 44px; /* iOS touch target size */
    position: relative;
  }
  .rank-slot {
    min-height: 70px;
    min-width: 170px;
  }
  .team-drop-zone {
    min-height: 100px;
  }
  /* Visual hint for long press */
  .player-tile::after, .ranking-player-tile::after {
    content: '⋮⋮';
    position: absolute;
    right: 4px;
    top: 50%;
    transform: translateY(-50%);
    color: var(--muted);
    font-size: 10px;
    opacity: 0.5;
  }
}
.rank-slot .rank-number{position:absolute;top:4px;left:8px;font-size:18px;font-weight:bold;color:var(--accent)}
.rank-slot.filled{background:#24262c}

.ranking-area{display:grid;grid-template-columns:repeat(auto-fit,minmax(180px,1fr));gap:12px;margin:16px 0}

.stats-table{width:100%;margin-top:12px}
.stats-table th{background:var(--chip);padding:8px;text-align:left;font-size:14px}
.stats-table td{padding:8px;font-size:14px;border-bottom:1px solid var(--stroke)}
.stats-table .emoji{font-size:18px;margin-right:4px}

.player-setup{margin-bottom:16px}
.unassigned-players{display:flex;flex-wrap:wrap;gap:8px;min-height:50px;padding:12px;background:#0f1115;border-radius:12px;margin:12px 0}

/* Player Pool for Ranking */
.player-pool-section{margin:16px 0}
.player-pool{display:flex;flex-wrap:wrap;gap:8px;min-height:60px;padding:12px;background:#0f1115;border:2px dashed var(--stroke);border-radius:12px;margin:8px 0}
.player-pool.drag-over{border-color:var(--accent);background:rgba(230,184,0,.05)}
.player-pool .player-tile{cursor:grab}
.player-pool .player-tile:active{cursor:grabbing}

/* Simplified player tiles for ranking */
.ranking-player-tile{display:inline-flex;align-items:center;gap:6px;padding:6px 10px;background:#1f2229;border:2px solid var(--stroke);border-radius:8px;cursor:move;user-select:none;-webkit-user-select:none;touch-action:none;transition:all .2s;font-size:14px}
.ranking-player-tile:hover{transform:translateY(-1px);box-shadow:0 2px 8px rgba(0,0,0,.2)}
.ranking-player-tile.dragging{opacity:.5;transform:scale(0.95)}
.ranking-player-tile .emoji{font-size:16px}
.ranking-player-tile .name{font-size:13px}

.ranking-section{margin-top:20px}
.ranking-area{display:grid;grid-template-columns:repeat(auto-fill,minmax(160px,1fr));gap:10px;margin:12px 0}
</style>
</head>
<body>
<div class="wrap">
  <h1>掼蛋升级计算器 v8.0 <span class="badge">玩家系统</span></h1>

  <!-- 玩家设置 -->
  <div class="card">
    <h3>玩家设置</h3>
    <div class="row">
      <label for="mode">人数：</label>
      <select id="mode"><option value="4">4 人</option><option value="6">6 人</option><option value="8" selected>8 人</option></select>
      <button id="generatePlayers">生成玩家</button>
      <button id="shuffleTeams">随机分配队伍</button>
    </div>
    <div class="unassigned-players" id="unassignedPlayers">
      <div class="small muted" style="width:100%">点击"生成玩家"开始</div>
    </div>
    
    <div class="grid">
      <div>
        <h4 id="team1Label">蓝队</h4>
        <div class="team-drop-zone" id="team1Zone" data-team="1">
          <div class="label">拖拽玩家到这里分配队伍</div>
        </div>
      </div>
      <div>
        <h4 id="team2Label">红队</h4>
        <div class="team-drop-zone" id="team2Zone" data-team="2">
          <div class="label">拖拽玩家到这里分配队伍</div>
        </div>
      </div>
    </div>
  </div>

  <!-- 本局排名 -->
  <div class="card">
    <h3>本局排名</h3>
    <div class="row">
      <div class="small">仅🈶1方可升级：</div><input type="checkbox" id="must1" checked>
      <span class="small muted" id="ruleHint"></span>
      <button id="clearRanking">清空排名</button>
      <button id="randomRanking">随机排名</button>
      <button id="manualCalc">手动计算</button>
    </div>
    
    <!-- 待排名玩家池 -->
    <div class="player-pool-section">
      <h4 class="small muted">待排名玩家</h4>
      <div class="player-pool" id="playerPool">
        <div class="small muted">请先分配玩家到队伍</div>
      </div>
    </div>
    
    <!-- 排名位置 -->
    <div class="ranking-section">
      <h4 class="small muted">拖拽玩家到对应排名</h4>
      <div class="ranking-area" id="rankingArea">
        <!-- Ranking slots will be generated here -->
      </div>
    </div>
    
    <div class="small muted" id="tip">从上方池中拖拽玩家到对应的排名位置</div>
  </div>

  <div class="grid">
    <div class="card">
      <h3>结果</h3>
      <div id="headline">—</div>
      <div id="explain" class="small muted">等待输入…</div>
      <hr>
      <div class="row" id="winBtnsWrap">
        <span class="small">获胜队：</span>
        <span id="winnerDisplay" style="font-weight:bold">—</span>
        <button id="apply">应用结果到战绩</button>
        <button id="advance" title="将本局级牌推进到预览的下一局">进入下一局</button>
      </div>
      <div class="small muted">
        A 局规则：胜方带末游→本局胜但不通关，失败数+1；A连败到3（A3）→仅该队回2。<br>
        严格模式：必须在自己的A级获胜才能通关 | 宽松模式：任何时候A级获胜都可通关
      </div>
      <div class="small muted toggle" style="margin-top:6px;">
        <input type="checkbox" id="autoNext"> <label for="autoNext">应用后自动进入下一局</label>
        <br>
        <input type="checkbox" id="autoApply"> <label for="autoApply" style="color:#4ade80;font-weight:bold">✅ 排名完成后自动应用结果（升级队伍）</label>
        <br>
        <input type="checkbox" id="strictA" checked> <label for="strictA" style="color:#f59e0b">🎯 严格A级规则（必须在自己的A级获胜才能通关）</label>
      </div>
      <span class="small muted" id="applyTip"></span>
    </div>

    <div class="card">
      <h3>队伍</h3>
      <div class="team">
        <span class="chip" id="t1NameChip"><b>蓝队</b></span><span class="chip">级牌：<b id="t1Lvl">2</b></span><span class="chip">A失败：<b id="t1A">0</b>/3</span><span class="chip">A状态：<b id="t1AState">—</b></span>
      </div>
      <div class="team">
        <span class="chip" id="t2NameChip"><b>红队</b></span><span class="chip">级牌：<b id="t2Lvl">2</b></span><span class="chip">A失败：<b id="t2A">0</b>/3</span><span class="chip">A状态：<b id="t2AState">—</b></span>
      </div>
      <hr>
      <div class="team">
        <span class="chip">本局级牌：<b id="curRoundLvl">2</b></span>
        <span class="chip">下局级牌（预览）：<b id="nextRoundPreview">-</b></span>
      </div>
    </div>
  </div>

  <div class="card">
    <h3>自定义规则</h3>
    <div class="grid">
      <details open><summary>4人升级表</summary>
        <div class="row" style="margin-top:8px;">
          <div>(1,2)= <input type="number" id="c4_12" value="3" min="0" max="5"></></div>
          <div>(1,3)= <input type="number" id="c4_13" value="2" min="0" max="5"></></div>
          <div>(1,4)= <input type="number" id="c4_14" value="1" min="0" max="5"></></div>
          <button id="save4">保存4人设置</button>
        </div>
      </details>
      <details><summary>6人阈值 & 分值</summary>
        <div class="row" style="margin-top:8px;">
          <div>升3级≥ <input type="number" id="t6_3" value="7"></div>
          <div>升2级≥ <input type="number" id="t6_2" value="4"></div>
          <div>升1级≥ <input type="number" id="t6_1" value="1"></div>
        </div>
        <div class="row" style="margin-top:8px;flex-wrap:wrap;gap:12px;">
          <div>1名分 <input type="number" id="p6_1" value="5" style="width:80px"></div>
          <div>2名分 <input type="number" id="p6_2" value="4" style="width:80px"></div>
          <div>3名分 <input type="number" id="p6_3" value="3" style="width:80px"></div>
          <div>4名分 <input type="number" id="p6_4" value="3" style="width:80px"></div>
          <div>5名分 <input type="number" id="p6_5" value="1" style="width:80px"></div>
          <div>6名分 <input type="number" id="p6_6" value="0" style="width:80px"></div>
        </div>
        <div class="row" style="margin-top:8px;"><button id="save6">保存6人设置</button></div>
      </details>
      <details><summary>8人阈值 & 分值</summary>
        <div class="row" style="margin-top:8px;">
          <div>升3级≥ <input type="number" id="t8_3" value="11"></div>
          <div>升2级≥ <input type="number" id="t8_2" value="6"></div>
          <div>升1级≥ <input type="number" id="t8_1" value="1"></div>
        </div>
        <div class="row" style="margin-top:8px;flex-wrap:wrap;gap:12px;">
          <div>1名分 <input type="number" id="p8_1" value="7" style="width:80px"></div>
          <div>2名分 <input type="number" id="p8_2" value="6" style="width:80px"></div>
          <div>3名分 <input type="number" id="p8_3" value="5" style="width:80px"></div>
          <div>4名分 <input type="number" id="p8_4" value="4" style="width:80px"></div>
          <div>5名分 <input type="number" id="p8_5" value="3" style="width:80px"></div>
          <div>6名分 <input type="number" id="p8_6" value="2" style="width:80px"></div>
          <div>7名分 <input type="number" id="p8_7" value="1" style="width:80px"></div>
          <div>8名分 <input type="number" id="p8_8" value="0" style="width:80px"></div>
        </div>
        <div class="row" style="margin-top:8px;"><button id="save8">保存8人设置</button></div>
      </details>
    </div>
  </div>

  <div class="card">
    <h3>历史战绩</h3>
    <div class="table-wrap">
      <table class="table" id="hist">
        <thead><tr>
          <th>#</th><th>时间</th><th>人数</th><th>胜方组合</th><th>玩家排名</th><th>升级情况</th><th>胜队</th>
          <th><span id="hT1"></span>级牌</th><th><span id="hT2"></span>级牌</th><th>本局级牌</th><th>A说明</th><th>操作</th>
        </tr></thead>
        <tbody id="histBody"></tbody>
      </table>
    </div>
    <div class="row btns-grid" style="margin-top:10px;">
      <button id="undo">撤销上一局</button>
      <button id="exportTxt">导出 TXT</button>
      <button id="exportCsv">导出 CSV</button>
      <button id="exportLongPng">导出 长图 PNG</button>
      <button id="resetMatch" style="border-color:#5b1e1e;color:#ffb3b3">重置整场</button>
      <span id="exportTip" class="small muted" style="grid-column:1/-1"></span>
    </div>
  </div>

  <!-- 玩家统计 -->
  <div class="grid">
    <div class="card">
      <h3>玩家排名统计</h3>
      <table class="stats-table">
        <thead>
          <tr>
            <th>玩家</th>
            <th>队伍</th>
            <th>场次</th>
            <th>平均排名</th>
            <th>拿1次数</th>
            <th>垫底次数</th>
          </tr>
        </thead>
        <tbody id="playerStatsBody">
          <tr><td colspan="6" class="muted small">暂无数据</td></tr>
        </tbody>
      </table>
    </div>

    <div class="card">
      <h3>队伍MVP & Burden</h3>
      <div id="team1Stats" style="margin-bottom:16px">
        <h4 id="team1StatsTitle">蓝队</h4>
        <div class="row">
          <span class="badge">MVP: <span id="team1MVP">—</span></span>
          <span class="badge">Burden: <span id="team1Burden">—</span></span>
        </div>
      </div>
      <div id="team2Stats">
        <h4 id="team2StatsTitle">红队</h4>
        <div class="row">
          <span class="badge">MVP: <span id="team2MVP">—</span></span>
          <span class="badge">Burden: <span id="team2Burden">—</span></span>
        </div>
      </div>
    </div>
  </div>
</div>

<canvas id="longCnv" width="1200" height="1600" style="display:none"></canvas>

<!-- Victory Modal -->
<div id="victoryModal" style="display:none; position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.8); z-index:9999; align-items:center; justify-content:center;">
  <div style="background:#1a1b1c; border-radius:16px; padding:32px; max-width:500px; text-align:center; border:3px solid #4ade80; transition: all 0.3s ease;">
    <h1 style="color:#fff; font-size:36px; margin:0 0 16px 0;">🎉 A级通关！🎉</h1>
    <h2 id="victoryTeamName" style="font-size:48px; margin:0 0 24px 0; font-weight:bold; text-shadow: 0 0 20px currentColor;"></h2>
    <p style="color:#999; font-size:18px; margin-bottom:32px;">恭喜完成所有级别的挑战！</p>
    
    <div style="display:flex; gap:16px; justify-content:center; flex-wrap:wrap;">
      <button onclick="exportTXT()" style="padding:12px 24px; background:#3b82f6; color:white; border:none; border-radius:8px; font-size:16px; cursor:pointer;">
        📄 导出 TXT
      </button>
      <button onclick="exportCSV()" style="padding:12px 24px; background:#3b82f6; color:white; border:none; border-radius:8px; font-size:16px; cursor:pointer;">
        📊 导出 CSV
      </button>
      <button onclick="exportLongPNG()" style="padding:12px 24px; background:#3b82f6; color:white; border:none; border-radius:8px; font-size:16px; cursor:pointer;">
        🖼️ 导出长图
      </button>
      <button onclick="resetAll()" style="padding:12px 24px; background:#ef4444; color:white; border:none; border-radius:8px; font-size:16px; cursor:pointer;">
        🔄 重置整场
      </button>
      <button onclick="closeVictoryModal()" style="padding:12px 24px; background:#666; color:white; border:none; border-radius:8px; font-size:16px; cursor:pointer;">
        关闭
      </button>
    </div>
  </div>
</div>

<script>
(function(){
  function $(id){ return document.getElementById(id); }
  function on(el,ev,fn){ el.addEventListener?el.addEventListener(ev,fn):el.attachEvent('on'+ev,fn); }
  function now(){ return new Date().toLocaleString(); }

  var modeSel=$('mode'), input = { value: '' }, must1=$('must1'), ruleHint=$('ruleHint');
  var tip=$('tip');
  var headline=$('headline'), explain=$('explain'), applyBtn=$('apply'), applyTip=$('applyTip'), advanceBtn=$('advance');
  var winnerDisplay=$('winnerDisplay');
  var autoNext=$('autoNext'), autoApply=$('autoApply'), strictA=$('strictA');
  var t1Lvl=$('t1Lvl'), t2Lvl=$('t2Lvl'), t1A=$('t1A'), t2A=$('t2A'), t1AState=$('t1AState'), t2AState=$('t2AState');
  var t1NameChip=$('t1NameChip'), t2NameChip=$('t2NameChip');
  var curRoundLvl=$('curRoundLvl'), nextRoundPreview=$('nextRoundPreview');
  var hT1=$('hT1'), hT2=$('hT2');
  var longCnv=$('longCnv'), lctx=longCnv.getContext('2d');
  var selected=[];

  // Storage
  var KEY_S='gd_v7_5_1_settings', KEY_ST='gd_v7_5_1_state';
  function load(key, def){ try{ var v=localStorage.getItem(key); return v?JSON.parse(v):def; }catch(e){ return def; } }
  function save(key, v){ try{ localStorage.setItem(key, JSON.stringify(v)); }catch(e){} }

  // Settings
  var S=load(KEY_S,{});
  if(!S.c4){ S.c4={'1,2':3,'1,3':2,'1,4':1}; }
  if(!S.t6){ S.t6={g3:7,g2:4,g1:1}; }
  if(!S.p6){ S.p6={1:5,2:4,3:3,4:3,5:1,6:0}; }
  if(!S.t8){ S.t8={g3:11,g2:6,g1:1}; }
  if(!S.p8){ S.p8={1:7,2:6,3:5,4:4,5:3,6:2,7:1,8:0}; }
  if(typeof S.must1==='undefined'){ S.must1=true; }
  if(typeof S.autoNext==='undefined'){ S.autoNext=true; } // Default to auto-advance
  if(typeof S.autoApply==='undefined'){ S.autoApply=true; } // Default to true for better UX
  if(typeof S.strictA==='undefined'){ S.strictA=true; } // Default to strict mode
  if(!S.t1){ S.t1={name:'蓝队', color:'#3b82f6'}; }
  if(!S.t2){ S.t2={name:'红队', color:'#ef4444'}; }

  // State
  var ST=load(KEY_ST,{});
  if(!ST.t1){ ST.t1={lvl:'2',aFail:0}; }
  if(!ST.t2){ ST.t2={lvl:'2',aFail:0}; }
  if(!ST.hist){ ST.hist=[]; }
  if(!ST.roundLevel){ ST.roundLevel='2'; }
  if(!ST.nextRoundBase){ ST.nextRoundBase=null; } // 关键：下一局应当打的级牌

  var winner='t1';

  // Player System Variables
  var players = [];
  var playerStats = {};
  var currentRanking = {};
  var draggedPlayer = null;
  var touchDraggedElement = null; // For touch dragging
  var touchClone = null; // Clone element for visual feedback during touch
  var touchStartTimer = null; // Timer for delayed drag start
  var touchStartPos = null; // Initial touch position
  var animalEmojis = ['🐶','🐱','🐭','🐹','🐰','🦊','🐻','🐼','🐨','🐯','🦁','🐮','🐷','🐸','🐵','🐔','🐧','🐦','🐤','🦆','🦅','🦉','🦇','🐺','🐗','🐴','🦄','🐝','🐛','🦋','🐌','🐞','🐜','🦟','🦗','🕷️','🦂','🐢','🐍','🦎','🦖','🦕','🐙','🦑','🦐','🦀','🐡','🐠','🐟','🐬','🐳','🐋','🦈'];
  
  // Touch event helper functions
  function handleTouchStart(e, player) {
    // Don't start drag if touching an input field
    if (e.target.tagName === 'INPUT') {
      return; // Allow normal input interaction
    }
    
    var touch = e.touches[0];
    var tile = e.currentTarget;
    
    // Store initial touch position
    touchStartPos = { x: touch.clientX, y: touch.clientY };
    
    // Set up delayed drag start (long press)
    touchStartTimer = setTimeout(function() {
      // Start drag after delay
      e.preventDefault();
      draggedPlayer = player;
      touchDraggedElement = tile;
      
      // Create clone for visual feedback
      touchClone = tile.cloneNode(true);
      touchClone.style.position = 'fixed';
      touchClone.style.zIndex = '1000';
      touchClone.style.opacity = '0.8';
      touchClone.style.pointerEvents = 'none';
      touchClone.style.transform = 'scale(1.1)';
      touchClone.classList.add('dragging');
      document.body.appendChild(touchClone);
      
      // Position clone at touch point
      touchClone.style.left = (touch.clientX - tile.offsetWidth/2) + 'px';
      touchClone.style.top = (touch.clientY - tile.offsetHeight/2) + 'px';
      
      // Hide the original tile while dragging
      tile.style.opacity = '0.3';
      tile.classList.add('dragging');
      
      // Add haptic feedback if available
      if (navigator.vibrate) {
        navigator.vibrate(10);
      }
    }, 200); // 200ms delay for long press
  }
  
  function handleTouchMove(e) {
    var touch = e.touches[0];
    
    // If we haven't started dragging yet, check for movement
    if (!touchClone && touchStartTimer && touchStartPos) {
      var dx = Math.abs(touch.clientX - touchStartPos.x);
      var dy = Math.abs(touch.clientY - touchStartPos.y);
      
      // Cancel drag start if user moves finger significantly
      if (dx > 10 || dy > 10) {
        clearTimeout(touchStartTimer);
        touchStartTimer = null;
        touchStartPos = null;
        return;
      }
    }
    
    // Only prevent default if we're actually dragging
    if (!touchClone) return;
    e.preventDefault();
    
    // Update clone position
    touchClone.style.left = (touch.clientX - touchClone.offsetWidth/2) + 'px';
    touchClone.style.top = (touch.clientY - touchClone.offsetHeight/2) + 'px';
    
    // Find element under touch point (excluding the clone)
    touchClone.style.display = 'none';
    var elementBelow = document.elementFromPoint(touch.clientX, touch.clientY);
    touchClone.style.display = 'block';
    
    // Highlight drop zones
    var dropZones = document.querySelectorAll('.rank-slot, .team-drop-zone, #playerPool');
    dropZones.forEach(function(zone) {
      zone.classList.remove('drag-over');
    });
    
    if (elementBelow) {
      var dropZone = elementBelow.closest('.rank-slot, .team-drop-zone, #playerPool');
      if (dropZone) {
        dropZone.classList.add('drag-over');
      }
    }
  }
  
  function handleTouchEnd(e) {
    // Clear the timer if it's still running
    if (touchStartTimer) {
      clearTimeout(touchStartTimer);
      touchStartTimer = null;
    }
    touchStartPos = null;
    
    // If we haven't started dragging, restore opacity and return
    if (!touchClone || !draggedPlayer) {
      if (touchDraggedElement) {
        touchDraggedElement.style.opacity = '';
        touchDraggedElement.classList.remove('dragging');
        touchDraggedElement = null;
      }
      return;
    }
    
    e.preventDefault();
    
    var touch = e.changedTouches[0];
    
    // Find element under touch point
    touchClone.style.display = 'none';
    var elementBelow = document.elementFromPoint(touch.clientX, touch.clientY);
    touchClone.style.display = 'block';
    
    // Handle drop
    console.log('Touch end - checking for drop target');
    console.log('Element below:', elementBelow);
    console.log('Dragged player:', draggedPlayer);
    
    if (elementBelow) {
      var rankSlot = elementBelow.closest('.rank-slot');
      var teamZone = elementBelow.closest('.team-drop-zone');
      var pool = elementBelow.closest('#playerPool');
      
      console.log('Found rankSlot:', rankSlot);
      console.log('Found teamZone:', teamZone);
      console.log('Found pool:', pool);
      
      if (rankSlot) {
        console.log('Dropping on rank slot');
        handleRankDrop(rankSlot, draggedPlayer);
      } else if (teamZone) {
        console.log('Dropping on team zone');
        handleTeamDrop(teamZone, draggedPlayer);
      } else if (pool) {
        console.log('Dropping on pool');
        handlePoolDrop(draggedPlayer);
      } else {
        console.log('No valid drop target found');
      }
    } else {
      console.log('No element below touch point');
    }
    
    // Clean up - ensure clone is removed
    if (touchClone) {
      if (touchClone.parentNode) {
        touchClone.parentNode.removeChild(touchClone);
      }
      touchClone = null;
    }
    
    // Also clean up any other floating clones that might exist
    var floatingClones = document.querySelectorAll('.dragging');
    floatingClones.forEach(function(clone) {
      if (clone.style.position === 'fixed' && clone !== touchDraggedElement) {
        if (clone.parentNode) {
          clone.parentNode.removeChild(clone);
        }
      }
    });
    
    if (touchDraggedElement) {
      touchDraggedElement.classList.remove('dragging');
      touchDraggedElement.style.opacity = ''; // Restore original opacity
      touchDraggedElement.style.display = ''; // Ensure visibility is restored
      touchDraggedElement = null;
    }
    
    draggedPlayer = null;
    
    // Clear all highlights
    var dropZones = document.querySelectorAll('.rank-slot, .team-drop-zone, #playerPool');
    dropZones.forEach(function(zone) {
      zone.classList.remove('drag-over');
    });
    
    // Force re-render to clean up any visual artifacts
    setTimeout(function() {
      renderPlayerPool();
      renderRankingSlots();
    }, 10);
  }
  
  function updateRankingInput() {
    console.log('=== updateRankingInput called ===');
    console.log('currentRanking:', JSON.stringify(currentRanking));
    console.log('players:', players.map(function(p) { return {id: p.id, name: p.name, team: p.team}; }));
    
    var mode = parseInt(modeSel.value);
    console.log('Mode:', mode);
    
    var isMobile = 'ontouchstart' in window;
    console.log('Is Mobile:', isMobile);
    
    if (!isMobile) {
      // Let desktop handle it the original way
      console.log('Desktop mode - returning');
      return;
    }
    
    // Check if all positions are filled
    var allFilled = true;
    var filledCount = 0;
    for (var i = 1; i <= mode; i++) {
      if (!currentRanking[i]) {
        allFilled = false;
        console.log('Position ' + i + ' is empty');
      } else {
        filledCount++;
        console.log('Position ' + i + ' has player:', currentRanking[i]);
      }
    }
    
    console.log('Filled positions:', filledCount + '/' + mode);
    
    if (!allFilled) {
      console.log('Not all positions filled - returning');
      return;
    }
    
    // For mobile, match desktop's calculateFromRanking logic
    // First determine the winner based on who has rank 1
    var firstPlacePlayerId = currentRanking[1];
    var firstPlacePlayer = players.find(function(p) { return p.id === firstPlacePlayerId; });
    
    if (!firstPlacePlayer) {
      console.log('Error: Could not find first place player');
      return;
    }
    
    console.log('First place player:', firstPlacePlayer.name, 'Team:', firstPlacePlayer.team);
    
    // Set winner based on first place player's team
    var actualWinner = firstPlacePlayer.team === 1 ? 't1' : 't2';
    setWinner(actualWinner);
    console.log('Set winner to:', actualWinner);
    
    // Collect ranks for each team
    var team1Ranks = [];
    var team2Ranks = [];
    
    for (var rank = 1; rank <= mode; rank++) {
      var playerId = currentRanking[rank];
      if (playerId) {
        var player = players.find(function(p) { return p.id === playerId; });
        if (player) {
          if (player.team === 1) {
            team1Ranks.push(rank);
          } else {
            team2Ranks.push(rank);
          }
        }
      }
    }
    
    console.log('Team 1 ranks:', team1Ranks);
    console.log('Team 2 ranks:', team2Ranks);
    
    // Use the winning team's ranks for calculation
    var winnerRanks = actualWinner === 't1' ? team1Ranks : team2Ranks;
    winnerRanks.sort(function(a, b) { return a - b; });
    
    console.log('Winner ranks (sorted):', winnerRanks);
    
    // Set input to winning team's ranks only (not player names!)
    input.value = winnerRanks.join(' ');
    selected = winnerRanks.slice();
    console.log('Setting input.value to:', input.value);
    console.log('Setting selected to:', selected);
    
    // Calculate and check for auto-apply
    var result = calc();
    console.log('Called calc(), result:', result);
    
    // Auto-apply if enabled and calculation successful
    if (S.autoApply && result && result.ok) {
      console.log('Auto-applying result');
      applyResult();
    }
  }
  
  function handleRankDrop(slot, player) {
    console.log('=== handleRankDrop called ===');
    console.log('Slot:', slot);
    console.log('Player:', player);
    
    var rank = parseInt(slot.dataset.rank);
    console.log('Rank position:', rank);
    
    if (!rank) {
      console.log('No rank - returning');
      return;
    }
    
    // Clean up any floating clones immediately
    var existingClones = document.querySelectorAll('.dragging');
    existingClones.forEach(function(clone) {
      if (clone.style.position === 'fixed') {
        clone.remove();
      }
    });
    
    // Remove player from any existing rank
    for (var r in currentRanking) {
      if (currentRanking[r] === player.id) {
        console.log('Removing player from previous rank:', r);
        delete currentRanking[r];
      }
    }
    
    // Remove any existing player from this rank
    if (currentRanking[rank]) {
      console.log('Rank ' + rank + ' already has player:', currentRanking[rank]);
      var oldPlayer = players.find(function(p) { return p.id === currentRanking[rank]; });
      if (oldPlayer) {
        // Return old player to pool
        var poolTile = createRankingPlayerTile(oldPlayer);
        $('playerPool').appendChild(poolTile);
      }
    }
    
    // Add player to new rank
    console.log('Adding player', player.id, 'to rank', rank);
    currentRanking[rank] = player.id;
    console.log('Current ranking after update:', JSON.stringify(currentRanking));
    
    // Re-render everything to ensure clean state
    renderPlayerPool();
    renderRankingSlots();
    updateRankingInput();
    calc();
  }
  
  function handleTeamDrop(zone, player) {
    // Clean up any floating clones
    var existingClones = document.querySelectorAll('.dragging');
    existingClones.forEach(function(clone) {
      if (clone.style.position === 'fixed') {
        clone.remove();
      }
    });
    
    var team = zone.dataset.team;
    if (team === '1') {
      player.team = 'A';
    } else if (team === '2') {
      player.team = 'B';
    }
    setupDropZones();
    renderRankingArea();
  }
  
  function handlePoolDrop(player) {
    // Clean up any floating clones
    var existingClones = document.querySelectorAll('.dragging');
    existingClones.forEach(function(clone) {
      if (clone.style.position === 'fixed') {
        clone.remove();
      }
    });
    
    // Remove from ranking
    for (var r in currentRanking) {
      if (currentRanking[r] === player.id) {
        delete currentRanking[r];
      }
    }
    // Re-render everything to ensure clean state
    renderPlayerPool();
    renderRankingSlots();
    updateRankingInput();
    calc();
  }
  
  // Player System Functions
  function generatePlayers() {
    var num = parseInt(modeSel.value);
    
    // Try to load saved players first
    var savedPlayers = load('gd_players', []);
    if (savedPlayers.length === num) {
      players = savedPlayers;
      // Ensure saved players have proper IDs and teams
      players.forEach(function(player, index) {
        if (!player.id || typeof player.id === 'string') {
          player.id = index + 1;
        }
        if (!player.team) {
          player.team = index % 2 === 0 ? 'A' : 'B';
        }
      });
    } else {
      players = [];
      
      // Shuffle emojis
      var shuffledEmojis = animalEmojis.slice().sort(function() { return Math.random() - 0.5; });
      
      for (var i = 0; i < num; i++) {
        var player = {
          id: i + 1,  // Numeric ID matching player number
          name: '玩家' + (i + 1),
          emoji: shuffledEmojis[i % shuffledEmojis.length],
          team: (i + 1)  // Store team as the player number for desktop compatibility
        };
        players.push(player);
      }
    }
    
    // Load saved player stats if available
    playerStats = load('gd_player_stats', {});
    
    renderPlayers();
    renderRankingArea();
  }
  
  function renderPlayers() {
    var unassigned = $('unassignedPlayers');
    var team1Zone = $('team1Zone');
    var team2Zone = $('team2Zone');
    
    // Clear zones
    unassigned.innerHTML = '';
    team1Zone.innerHTML = '<div class="label">拖拽玩家到这里分配队伍</div>';
    team2Zone.innerHTML = '<div class="label">拖拽玩家到这里分配队伍</div>';
    
    players.forEach(function(player) {
      var tile = createPlayerTile(player);
      
      if (player.team === 1) {
        team1Zone.appendChild(tile);
        tile.style.borderColor = S.t1.color;
      } else if (player.team === 2) {
        team2Zone.appendChild(tile);
        tile.style.borderColor = S.t2.color;
      } else {
        unassigned.appendChild(tile);
      }
    });
    
    updateTeamLabels();
  }
  
  function createPlayerTile(player) {
    var tile = document.createElement('div');
    tile.className = 'player-tile';
    tile.draggable = true;
    tile.dataset.playerId = player.id;
    
    var emoji = document.createElement('span');
    emoji.className = 'emoji';
    emoji.textContent = player.emoji;
    
    var nameInput = document.createElement('input');
    nameInput.type = 'text';
    nameInput.value = player.name;
    nameInput.onclick = function(e) { e.stopPropagation(); };
    // Update with debouncing for performance
    var updateTimer = null;
    var updateName = function() {
      player.name = this.value;
      save('gd_players', players);
      
      // Debounce the UI updates
      if (updateTimer) clearTimeout(updateTimer);
      updateTimer = setTimeout(function() {
        // Update ranking display if this player is ranked
        renderPlayerPool();
        renderRankingSlots();
        // Also update statistics display
        renderStatistics();
      }, 300);
    };
    nameInput.oninput = updateName;
    nameInput.onchange = function() {
      player.name = this.value;
      save('gd_players', players);
      // Immediate update on change (blur)
      if (updateTimer) clearTimeout(updateTimer);
      renderPlayerPool();
      renderRankingSlots();
      renderStatistics();
    };
    
    tile.appendChild(emoji);
    tile.appendChild(nameInput);
    
    // Drag events
    tile.ondragstart = function(e) {
      draggedPlayer = player;
      tile.classList.add('dragging');
      e.dataTransfer.effectAllowed = 'move';
    };
    
    tile.ondragend = function() {
      tile.classList.remove('dragging');
      draggedPlayer = null;
    };
    
    // Touch events for mobile
    tile.addEventListener('touchstart', function(e) {
      handleTouchStart(e, player);
    }, { passive: false });
    
    tile.addEventListener('touchmove', handleTouchMove, { passive: false });
    
    tile.addEventListener('touchend', handleTouchEnd, { passive: false });
    
    tile.addEventListener('touchcancel', handleTouchEnd, { passive: false });
    
    return tile;
  }
  
  function setupDropZones() {
    var zones = [
      { el: $('unassignedPlayers'), team: null },
      { el: $('team1Zone'), team: 1 },
      { el: $('team2Zone'), team: 2 }
    ];
    
    zones.forEach(function(zone) {
      zone.el.ondragover = function(e) {
        e.preventDefault();
        zone.el.classList.add('drag-over');
      };
      
      zone.el.ondragleave = function() {
        zone.el.classList.remove('drag-over');
      };
      
      zone.el.ondrop = function(e) {
        e.preventDefault();
        zone.el.classList.remove('drag-over');
        
        if (draggedPlayer) {
          draggedPlayer.team = zone.team;
          save('gd_players', players);
          renderPlayers();
          renderRankingArea();
        }
      };
    });
  }
  
  function shuffleTeams() {
    var num = parseInt(modeSel.value);
    var halfSize = num / 2;
    
    // Shuffle players
    var shuffled = players.slice().sort(function() { return Math.random() - 0.5; });
    
    // Assign to teams
    shuffled.forEach(function(player, i) {
      player.team = i < halfSize ? 1 : 2;
    });
    
    save('gd_players', players);
    renderPlayers();
    renderRankingArea();
  }
  
  function renderRankingArea() {
    var pool = $('playerPool');
    var area = $('rankingArea');
    var num = parseInt(modeSel.value);
    var allAssigned = players.every(function(p) { return p.team !== null; });
    
    if (!allAssigned) {
      pool.innerHTML = '<div class="small muted">请先分配所有玩家到队伍</div>';
      area.innerHTML = '';
      return;
    }
    
    // Render player pool
    renderPlayerPool();
    
    // Render ranking slots
    area.innerHTML = '';
    
    for (var rank = 1; rank <= num; rank++) {
      var slot = document.createElement('div');
      slot.className = 'rank-slot';
      slot.dataset.rank = rank;
      
      var number = document.createElement('div');
      number.className = 'rank-number';
      number.textContent = '第' + rank + '名';
      slot.appendChild(number);
      
      // Drop events for ranking
      slot.ondragover = function(e) {
        e.preventDefault();
        this.classList.add('drag-over');
      };
      
      slot.ondragleave = function() {
        this.classList.remove('drag-over');
      };
      
      slot.ondrop = (function(r) {
        return function(e) {
          e.preventDefault();
          this.classList.remove('drag-over');
          
          if (draggedPlayer) {
            // Check if another player was already in this rank
            var existingPlayerId = currentRanking[r];
            if (existingPlayerId && existingPlayerId !== draggedPlayer.id) {
              // Move existing player back to pool
              delete currentRanking[r];
            }
            
            // Remove from previous rank if any
            for (var oldRank in currentRanking) {
              if (currentRanking[oldRank] === draggedPlayer.id) {
                delete currentRanking[oldRank];
                break;
              }
            }
            
            // Add to new rank
            currentRanking[r] = draggedPlayer.id;
            renderPlayerPool();
            renderRankingSlots();
            // Force check auto calculate after updating ranking
            setTimeout(function() {
              checkAutoCalculate();
            }, 100);
          }
        };
      })(rank);
      
      area.appendChild(slot);
    }
  }
  
  function renderPlayerPool() {
    var pool = $('playerPool');
    pool.innerHTML = '';
    
    // Add drop zone for returning players to pool
    pool.ondragover = function(e) {
      e.preventDefault();
      pool.classList.add('drag-over');
    };
    
    pool.ondragleave = function() {
      pool.classList.remove('drag-over');
    };
    
    pool.ondrop = function(e) {
      e.preventDefault();
      pool.classList.remove('drag-over');
      
      if (draggedPlayer) {
        // Remove from ranking
        for (var rank in currentRanking) {
          if (currentRanking[rank] === draggedPlayer.id) {
            delete currentRanking[rank];
            break;
          }
        }
        renderPlayerPool();
        renderRankingSlots();
        checkAutoCalculate();
      }
    };
    
    // Add players not yet ranked
    players.forEach(function(player) {
      var isRanked = false;
      for (var rank in currentRanking) {
        if (currentRanking[rank] === player.id) {
          isRanked = true;
          break;
        }
      }
      
      if (!isRanked) {
        var tile = createRankingPlayerTile(player);
        pool.appendChild(tile);
      }
    });
    
    if (pool.children.length === 0) {
      pool.innerHTML = '<div class="small muted">所有玩家已排名</div>';
    }
  }
  
  function createRankingPlayerTile(player) {
    var tile = document.createElement('div');
    tile.className = 'ranking-player-tile';
    tile.draggable = true;
    tile.dataset.playerId = player.id;
    
    // Apply team color
    tile.style.borderColor = player.team === 1 ? S.t1.color : S.t2.color;
    
    var emoji = document.createElement('span');
    emoji.className = 'emoji';
    emoji.textContent = player.emoji;
    
    var name = document.createElement('span');
    name.className = 'name';
    name.textContent = player.name;
    
    tile.appendChild(emoji);
    tile.appendChild(name);
    
    // Drag events
    tile.ondragstart = function(e) {
      draggedPlayer = player;
      tile.classList.add('dragging');
      e.dataTransfer.effectAllowed = 'move';
    };
    
    tile.ondragend = function() {
      tile.classList.remove('dragging');
      draggedPlayer = null;
    };
    
    // Touch events for mobile
    tile.addEventListener('touchstart', function(e) {
      handleTouchStart(e, player);
    }, { passive: false });
    
    tile.addEventListener('touchmove', handleTouchMove, { passive: false });
    
    tile.addEventListener('touchend', handleTouchEnd, { passive: false });
    
    tile.addEventListener('touchcancel', handleTouchEnd, { passive: false });
    
    return tile;
  }
  
  function renderRankingSlots() {
    var area = $('rankingArea');
    var slots = area.querySelectorAll('.rank-slot');
    
    slots.forEach(function(slot) {
      var rank = parseInt(slot.dataset.rank);
      var playerId = currentRanking[rank];
      
      // Remove existing player tiles (keep rank number)
      var existingTiles = slot.querySelectorAll('.ranking-player-tile');
      existingTiles.forEach(function(t) { t.remove(); });
      
      if (playerId) {
        var player = players.find(function(p) { return p.id === playerId; });
        if (player) {
          var tile = createRankingPlayerTile(player);
          slot.appendChild(tile);
          slot.classList.add('filled');
        }
      } else {
        slot.classList.remove('filled');
      }
    });
  }
  
  function clearRanking() {
    currentRanking = {};
    renderPlayerPool();
    renderRankingSlots();
    checkAutoCalculate();
  }
  
  function randomizeRanking() {
    var num = parseInt(modeSel.value);
    
    // Check if all players are assigned to teams
    var allAssigned = players.every(function(p) { return p.team !== null; });
    if (!allAssigned) {
      alert('请先分配所有玩家到队伍');
      return;
    }
    
    // Clear current ranking
    currentRanking = {};
    
    // Create a shuffled array of player IDs
    var playerIds = players.map(function(p) { return p.id; });
    
    // Fisher-Yates shuffle
    for (var i = playerIds.length - 1; i > 0; i--) {
      var j = Math.floor(Math.random() * (i + 1));
      var temp = playerIds[i];
      playerIds[i] = playerIds[j];
      playerIds[j] = temp;
    }
    
    // Assign shuffled players to ranking positions
    for (var rank = 1; rank <= num; rank++) {
      currentRanking[rank] = playerIds[rank - 1];
    }
    
    console.log('Randomized ranking:', currentRanking);
    
    // Update display
    renderPlayerPool();
    renderRankingSlots();
    
    // Auto calculate
    checkAutoCalculate();
  }
  
  
  function checkAutoCalculate() {
    var num = parseInt(modeSel.value);
    var rankedCount = 0;
    
    // Count how many players are actually ranked
    for (var i = 1; i <= num; i++) {
      if (currentRanking[i]) {
        rankedCount++;
      }
    }
    
    // Show current state
    console.log('checkAutoCalculate: ranked', rankedCount, 'of', num);
    
    var allRanked = rankedCount === num;
    
    if (allRanked) {
      console.log('All players ranked, calculating...');
      calculateFromRanking();
    } else {
      // Show progress
      headline.textContent = '已排名 ' + rankedCount + ' / ' + num + ' 位玩家';
      explain.textContent = '请继续拖拽剩余玩家到排名位置';
      if (winnerDisplay) winnerDisplay.textContent = '—';
    }
  }
  
  function calculateFromRanking() {
    var num = parseInt(modeSel.value);
    
    // Count properly ranked players
    var rankedCount = 0;
    for (var i = 1; i <= num; i++) {
      if (currentRanking[i]) {
        rankedCount++;
      }
    }
    
    console.log('calculateFromRanking: ranked', rankedCount, 'of', num);
    
    if (rankedCount !== num) {
      // If not all players are ranked, clear results
      headline.textContent = '等待排名完成 (' + rankedCount + '/' + num + ')';
      explain.textContent = '请将所有玩家拖到排名位置';
      if (winnerDisplay) winnerDisplay.textContent = '—';
      return;
    }
    
    // First, determine who won based on who has rank 1
    var firstPlacePlayerId = currentRanking[1];
    if (!firstPlacePlayerId) {
      headline.textContent = '错误：未找到第1名';
      return;
    }
    
    var firstPlacePlayer = players.find(function(p) { return p.id === firstPlacePlayerId; });
    
    if (!firstPlacePlayer) {
      headline.textContent = '错误：未找到第1名玩家';
      return;
    }
    
    // Set winner based on who has first place
    var actualWinner = firstPlacePlayer.team === 1 ? 't1' : 't2';
    setWinner(actualWinner);
    
    var team1Ranks = [];
    var team2Ranks = [];
    
    for (var rank = 1; rank <= num; rank++) {
      var playerId = currentRanking[rank];
      if (playerId) {
        var player = players.find(function(p) { return p.id === playerId; });
        if (player) {
          if (player.team === 1) {
            team1Ranks.push(rank);
          } else {
            team2Ranks.push(rank);
          }
        }
      }
    }
    
    // Use the winning team's ranks for calculation
    var winnerRanks = actualWinner === 't1' ? team1Ranks : team2Ranks;
    winnerRanks.sort(function(a, b) { return a - b; });
    
    // Set the ranks input value
    input.value = winnerRanks.join(' ');
    selected = winnerRanks.slice();
    
    // Calculate and display results
    var result = calc();
    
    // Auto-apply if enabled and calculation successful
    if (S.autoApply && result.ok) {
      applyResult();
    }
  }
  
  function updatePlayerStats() {
    var num = parseInt(modeSel.value);
    var lastPlace = num; // 4, 6, or 8 depending on mode
    
    for (var rank = 1; rank <= num; rank++) {
      var playerId = currentRanking[rank];
      if (playerId) {
        var player = players.find(function(p) { return p.id === playerId; });
        if (player) {
          if (!playerStats[playerId]) {
            playerStats[playerId] = {
              games: 0,
              totalRank: 0,
              firstPlaceCount: 0,  // Count of 1st place finishes
              lastPlaceCount: 0,   // Count of last place finishes
              rankings: []
            };
          }
          
          var stats = playerStats[playerId];
          stats.games++;
          stats.totalRank += rank;
          stats.rankings.push(rank);
          
          // Count first and last places
          if (rank === 1) {
            stats.firstPlaceCount = (stats.firstPlaceCount || 0) + 1;
          }
          if (rank === lastPlace) {
            stats.lastPlaceCount = (stats.lastPlaceCount || 0) + 1;
          }
        }
      }
    }
    
    save('gd_player_stats', playerStats);
    renderStatistics();
  }
  
  function renderStatistics() {
    renderPlayerStatsTable();
    renderTeamMVPBurden();
  }
  
  function renderPlayerStatsTable() {
    var tbody = $('playerStatsBody');
    tbody.innerHTML = '';
    
    // Collect player data with stats
    var playerData = [];
    players.forEach(function(player) {
      var stats = playerStats[player.id];
      if (stats && stats.games > 0) {
        var avgRank = stats.totalRank / stats.games;
        playerData.push({
          player: player,
          stats: stats,
          avgRank: avgRank
        });
      }
    });
    
    if (playerData.length === 0) {
      tbody.innerHTML = '<tr><td colspan="6" class="muted small">暂无数据</td></tr>';
      return;
    }
    
    // Sort by team first, then by average ranking (best to worst within each team)
    playerData.sort(function(a, b) {
      // First sort by team
      if (a.player.team !== b.player.team) {
        return (a.player.team || 999) - (b.player.team || 999); // Unassigned teams go last
      }
      // Then sort by average rank within team (lower is better)
      return a.avgRank - b.avgRank;
    });
    
    // Render sorted data
    playerData.forEach(function(data) {
      var player = data.player;
      var stats = data.stats;
      var tr = document.createElement('tr');
      var avgRankDisplay = data.avgRank.toFixed(2);
      var teamName = player.team === 1 ? S.t1.name : (player.team === 2 ? S.t2.name : '未分配');
      var teamColor = player.team === 1 ? S.t1.color : (player.team === 2 ? S.t2.color : '#666');
      
      // Add subtle team background
      if (player.team === 1 || player.team === 2) {
        tr.style.background = 'linear-gradient(90deg, ' + teamColor + '08, transparent)';
      }
      
      tr.innerHTML = '<td><span class="emoji">' + player.emoji + '</span>' + player.name + '</td>' +
                    '<td><span style="color:' + teamColor + ';font-weight:bold">' + teamName + '</span></td>' +
                    '<td>' + stats.games + '</td>' +
                    '<td><b>' + avgRankDisplay + '</b></td>' +
                    '<td>' + (stats.firstPlaceCount || 0) + '</td>' +
                    '<td>' + (stats.lastPlaceCount || 0) + '</td>';
      tbody.appendChild(tr);
    });
  }
  
  function renderTeamMVPBurden() {
    var team1Players = players.filter(function(p) { return p.team === 1; });
    var team2Players = players.filter(function(p) { return p.team === 2; });
    
    function findMVPAndBurden(teamPlayers) {
      var mvp = null, burden = null;
      var bestAvg = 999, worstAvg = 0;
      
      teamPlayers.forEach(function(player) {
        var stats = playerStats[player.id];
        if (stats && stats.games > 0) {
          var avg = stats.totalRank / stats.games;
          if (avg < bestAvg) {
            bestAvg = avg;
            mvp = player;
          }
          if (avg > worstAvg) {
            worstAvg = avg;
            burden = player;
          }
        }
      });
      
      return { mvp: mvp, burden: burden };
    }
    
    var team1Result = findMVPAndBurden(team1Players);
    var team2Result = findMVPAndBurden(team2Players);
    
    $('team1StatsTitle').textContent = S.t1.name;
    $('team2StatsTitle').textContent = S.t2.name;
    
    $('team1MVP').innerHTML = team1Result.mvp ? 
      '<span class="emoji">' + team1Result.mvp.emoji + '</span>' + team1Result.mvp.name : '—';
    $('team1Burden').innerHTML = team1Result.burden ? 
      '<span class="emoji">' + team1Result.burden.emoji + '</span>' + team1Result.burden.name : '—';
    
    $('team2MVP').innerHTML = team2Result.mvp ? 
      '<span class="emoji">' + team2Result.mvp.emoji + '</span>' + team2Result.mvp.name : '—';
    $('team2Burden').innerHTML = team2Result.burden ? 
      '<span class="emoji">' + team2Result.burden.emoji + '</span>' + team2Result.burden.name : '—';
  }
  
  function updateTeamLabels() {
    $('team1Label').textContent = S.t1.name;
    $('team2Label').textContent = S.t2.name;
    $('team1Label').style.color = S.t1.color;
    $('team2Label').style.color = S.t2.color;
  }

  // Utils
  function hexToRgb(hex){ var h=hex.replace('#',''); if(h.length===3) h=h[0]+h[0]+h[1]+h[1]+h[2]+h[2]; return {r:parseInt(h.substr(0,2),16),g:parseInt(h.substr(2,2),16),b:parseInt(h.substr(4,2),16)}; }
  function rgba(hex,a){ var c=hexToRgb(hex); return 'rgba('+c.r+','+c.g+','+c.b+','+a+')'; }
  function setWinner(w){ 
    winner=w; 
    if (winnerDisplay) {
      winnerDisplay.textContent = w === 't1' ? S.t1.name : S.t2.name;
      winnerDisplay.style.color = w === 't1' ? S.t1.color : S.t2.color;
    }
    refreshPreviewOnly(); 
  }
  function addRipple(ev,el,color){ var r=document.createElement('span'); var rect=el.getBoundingClientRect(), d=Math.max(rect.width,rect.height)*1.4; r.className='ripple'; r.style.width=r.style.height=d+'px'; r.style.left=(ev.clientX-rect.left-d/2)+'px'; r.style.top=(ev.clientY-rect.top-d/2)+'px'; r.style.background=rgba(color,.35); el.appendChild(r); setTimeout(function(){ if(r.parentNode) r.parentNode.removeChild(r); },650); }

  function applyTeamStyles(){ 
    t1NameChip.style.background=S.t1.color; 
    t2NameChip.style.background=S.t2.color; 
    t1NameChip.style.color=t2NameChip.style.color='#fff'; 
    t1NameChip.innerHTML='<b>'+S.t1.name+'</b>'; 
    t2NameChip.innerHTML='<b>'+S.t2.name+'</b>'; 
    hT1.innerText=S.t1.name; 
    hT2.innerText=S.t2.name; 
    autoNext.checked=!!S.autoNext;
    autoApply.checked=!!S.autoApply;
    strictA.checked=!!S.strictA; 
    // Update winner display if set
    if (winnerDisplay && winner) {
      winnerDisplay.textContent = winner === 't1' ? S.t1.name : S.t2.name;
      winnerDisplay.style.color = winner === 't1' ? S.t1.color : S.t2.color;
    }
  }
  applyTeamStyles();

  function updateRuleHint(){ var mode=modeSel.value; if(mode==='4'){ ruleHint.textContent='4人：固定表 ('+S.c4['1,2']+','+S.c4['1,3']+','+S.c4['1,4']+')'; } else if(mode==='6'){ ruleHint.textContent='6人：分差≥'+S.t6.g3+' 升3；≥'+S.t6.g2+' 升2；≥'+S.t6.g1+' 升1'; } else { ruleHint.textContent='8人：分差≥'+S.t8.g3+' 升3；≥'+S.t8.g2+' 升2；≥'+S.t8.g1+' 升1'; } }
  updateRuleHint();

  function renderTeams(){ 
    t1Lvl.textContent=ST.t1.lvl; 
    t2Lvl.textContent=ST.t2.lvl; 
    t1A.textContent=ST.t1.aFail||0; 
    t2A.textContent=ST.t2.aFail||0; 
    t1AState.textContent=(ST.t1.lvl==='A')?('A'+(ST.t1.aFail||0)+'/3'):'—'; 
    t2AState.textContent=(ST.t2.lvl==='A')?('A'+(ST.t2.aFail||0)+'/3'):'—'; 
    
    // Show which team's level we're playing at
    var roundTeamName = '';
    if (String(ST.roundLevel) === String(ST.t1.lvl) && String(ST.roundLevel) !== String(ST.t2.lvl)) {
      roundTeamName = ' (' + S.t1.name + ')';
    } else if (String(ST.roundLevel) === String(ST.t2.lvl) && String(ST.roundLevel) !== String(ST.t1.lvl)) {
      roundTeamName = ' (' + S.t2.name + ')';
    }
    curRoundLvl.textContent = ST.roundLevel + roundTeamName;
    console.log('renderTeams: displaying roundLevel =', ST.roundLevel, 'with team name =', roundTeamName);
    
    // Show next round preview with team name
    var nextRound = ST.nextRoundBase || ST.roundLevel || '-';
    var nextTeamName = '';
    if (ST.nextRoundBase) {
      // There's a pending next round, figure out which team it would be
      if (ST.nextRoundBase === ST.t1.lvl && ST.nextRoundBase !== ST.t2.lvl) {
        nextTeamName = ' (' + S.t1.name + ')';
      } else if (ST.nextRoundBase === ST.t2.lvl && ST.nextRoundBase !== ST.t1.lvl) {
        nextTeamName = ' (' + S.t2.name + ')';
      }
    }
    nextRoundPreview.textContent = nextRound + nextTeamName;
  }
  renderTeams();

  // Rules saving
  function collectAndSaveRules(){ S.c4={'1,2':+$('c4_12').value||0,'1,3':+$('c4_13').value||0,'1,4':+$('c4_14').value||0}; S.t6={g3:+$('t6_3').value||7,g2:+$('t6_2').value||4,g1:+$('t6_1').value||1}; S.p6={1:+$('p6_1').value||0,2:+$('p6_2').value||0,3:+$('p6_3').value||0,4:+$('p6_4').value||0,5:+$('p6_5').value||0,6:+$('p6_6').value||0}; S.t8={g3:+$('t8_3').value||11,g2:+$('t8_2').value||6,g1:+$('t8_1').value||1}; S.p8={1:+$('p8_1').value||0,2:+$('p8_2').value||0,3:+$('p8_3').value||0,4:+$('p8_4').value||0,5:+$('p8_5').value||0,6:+$('p8_6').value||0,7:+$('p8_7').value||0,8:+$('p8_8').value||0}; save(KEY_S,S); updateRuleHint(); refreshPreviewOnly(); }
  on($('save4'),'click',collectAndSaveRules); on($('save6'),'click',collectAndSaveRules); on($('save8'),'click',collectAndSaveRules);
  must1.checked=!!S.must1; on(must1,'change',function(){ S.must1=!!must1.checked; save(KEY_S,S); refreshPreviewOnly(); });
  on(autoNext,'change',function(){ S.autoNext=!!autoNext.checked; save(KEY_S,S); });
  on(autoApply,'change',function(){ S.autoApply=!!autoApply.checked; save(KEY_S,S); });
  on(strictA,'change',function(){ S.strictA=!!strictA.checked; save(KEY_S,S); });

  // Helpers
  function parseRanks(text, need){ if(!text) return {ok:false,msg:'请输入名次'}; var t=String(text).trim(), maxn=(need===2?4:(need===3?6:8)), re=new RegExp('^[0-9]{'+need+'}$'); if(re.test(t)){ var arr=t.split(''), nums=[], i; for(i=0;i<arr.length;i++) nums.push(parseInt(arr[i],10)); var seen={}, j; for(j=0;j<nums.length;j++){ if(nums[j]<1||nums[j]>maxn) return {ok:false,msg:'名次超出范围'}; if(seen[nums[j]]) return {ok:false,msg:'名次不能重复'}; seen[nums[j]]=1; } nums.sort(function(a,b){return a-b;}); return {ok:true,ranks:nums}; } var parts=t.replace(/[^0-9]+/g,' ').trim().split(/\s+/); if(parts.length!==need) return {ok:false,msg:'需要 '+need+' 个名次'}; var nums2=[], k; for(k=0;k<parts.length;k++){ var n=parseInt(parts[k],10); if(!(n>=1&&n<=maxn)) return {ok:false,msg:'名次必须在 1~'+maxn}; nums2.push(n); } var seen2={}, m; for(m=0;m<nums2.length;m++){ if(seen2[nums2[m]]) return {ok:false,msg:'名次不能重复'}; seen2[nums2[m]]=1; } nums2.sort(function(a,b){return a-b;}); return {ok:true,ranks:nums2}; }
  function sum(a){var s=0,i;for(i=0;i<a.length;i++)s+=a[i];return s;}
  function scoreSum(r,map){var s=0,i;for(i=0;i<r.length;i++)s+=(map[r[i]]||0);return s;}
  function tier(diff,t){if(diff>=t.g3)return 3;if(diff>=t.g2)return 2;if(diff>=t.g1)return 1;return 0;}
  function nextLevel(curr,inc){var L=['2','3','4','5','6','7','8','9','10','J','Q','K','A'];var i=Math.max(0,L.indexOf(curr));return L[Math.min(L.length-1,i+inc)];}

  function calc(){
    var mode=modeSel.value, need=(mode==='4'?2:(mode==='6'?3:4));
    
    // Check if we have valid ranking input
    if (!input.value) {
      headline.textContent='等待排名完成';
      explain.textContent='请将所有玩家拖到排名位置';
      refreshPreviewOnly();
      return {ok:false};
    }
    
    var pr=parseRanks(input.value, need);
    if(!pr.ok){ headline.textContent='输入有误'; explain.textContent=pr.msg; refreshPreviewOnly(); return {ok:false}; }
    var r=pr.ranks, up=0, ours=null, opp=null, diff=null;
    if(mode==='4'){ up=S.c4[r[0]+','+r[1]]||0; }
    else if(mode==='6'){ ours=scoreSum(r,S.p6); opp=sum([S.p6[1],S.p6[2],S.p6[3],S.p6[4],S.p6[5],S.p6[6]])-ours; diff=ours-opp; up=(S.must1 && r.indexOf(1)===-1)?0:tier(diff,S.t6); }
    else{ 
      // Special case: if team gets 1,2,3,4 (complete sweep), upgrade 4 levels
      if(r.length === 4 && r[0] === 1 && r[1] === 2 && r[2] === 3 && r[3] === 4) {
        up = 4;
      } else {
        ours=scoreSum(r,S.p8); opp=sum([S.p8[1],S.p8[2],S.p8[3],S.p8[4],S.p8[5],S.p8[6],S.p8[7],S.p8[8]])-ours; diff=ours-opp; up=(S.must1 && r.indexOf(1)===-1)?0:tier(diff,S.t8);
      }
    }
    // Add team name to upgrade label
    var winnerName = winner === 't1' ? S.t1.name : S.t2.name;
    var label=(up>0?(winnerName+' 升 '+up+' 级'):'不升级');
    var base=ST.roundLevel;
    // Calculate what the next round would be if we apply this result
    var winnerCurrentLevel = (winner==='t1')?ST.t1.lvl:ST.t2.lvl;
    var winnerNewLevel = nextLevel(winnerCurrentLevel, up);
    var preview = ST.nextRoundBase || winnerNewLevel;
    // Get team names for display
    var winnerName = winner === 't1' ? S.t1.name : S.t2.name;
    var loserName = winner === 't1' ? S.t2.name : S.t1.name;
    var currentRoundTeam = base === ST.t1.lvl ? S.t1.name : (base === ST.t2.lvl ? S.t2.name : '');
    headline.textContent=(mode+'人：'+ '('+r.join(',')+')'+' → '+label+'｜本局 '+base+(currentRoundTeam?' ('+currentRoundTeam+')':'')+' → 下局 '+preview+' ('+winnerName+')');
    explain.textContent=(mode==='4'?'4人表：(1,2)='+S.c4['1,2']+'；(1,3)='+S.c4['1,3']+'；(1,4)='+S.c4['1,4'] : '分差与资格规则已计算');
    refreshPreviewOnly();
    return {ok:true,mode:mode,ranks:r,up:up,base:base,preview:winnerNewLevel};
  }

  function refreshPreviewOnly(){ 
    // If there's a pending next round, show it. Otherwise show current winner's level
    if (ST.nextRoundBase) {
      nextRoundPreview.textContent = ST.nextRoundBase;
    } else {
      // In auto-next mode or no pending round, preview is same as current round
      nextRoundPreview.textContent = ST.roundLevel || '-';
    }
  }


  // History
  var histBody=$('histBody'), exportTip=$('exportTip');
  function renderHistory(){ 
    histBody.innerHTML=''; 
    for(var i=0;i<ST.hist.length;i++){ 
      (function(idx){ 
        var h=ST.hist[idx]; 
        var tr=document.createElement('tr'); 
        tr.className='tinted'; 
        // Add color coding based on winning team
        var winColor = h.winKey === 't1' ? S.t1.color : S.t2.color;
        tr.style.background = 'linear-gradient(90deg, ' + winColor + '10, transparent)';
        
        // Add team name to upgrade display
        var upgradeText = h.up ? (h.win + ' 升' + h.up + '级') : '不升级';
        
        // Build player ranking display if available
        var rankingDisplay = '';
        if (h.playerRankings) {
          var rankingParts = [];
          for (var i = 1; i <= parseInt(h.mode); i++) {
            if (h.playerRankings[i]) {
              var p = h.playerRankings[i];
              var teamColor = p.team === 1 ? S.t1.color : S.t2.color;
              rankingParts.push('<span style="color:' + teamColor + '">' + p.emoji + p.name + '</span>');
            }
          }
          if (rankingParts.length > 0) {
            rankingDisplay = rankingParts.join(' ');
          }
        }
        
        // Keep the original combo display
        var comboDisplay = h.combo || '';
        
        tr.innerHTML='<td>'+(idx+1)+'</td><td>'+h.ts+'</td><td>'+h.mode+'</td><td>'+comboDisplay+'</td><td>'+rankingDisplay+'</td><td>'+upgradeText+'</td><td style="color:'+winColor+';font-weight:bold">'+h.win+'</td><td>'+h.t1+'</td><td>'+h.t2+'</td><td>'+h.round+'</td><td>'+h.aNote+'</td>'; 
        var td=document.createElement('td'); 
        var b=document.createElement('button'); 
        b.textContent='回滚至此前'; 
        b.onclick=function(){ rollbackTo(idx); }; 
        td.appendChild(b); 
        tr.appendChild(td); 
        histBody.appendChild(tr); 
      })(i); 
    } 
  }

  // Apply & advance
  function applyResult(){ var r=calc(); if(!r.ok){ applyTip.textContent='请先计算'; return; } var win=winner, lose=(win==='t1'?'t2':'t1'); var thisRound = ST.roundLevel;
    // Snapshot
    var snap={prevT1Lvl:ST.t1.lvl,prevT1A:ST.t1.aFail||0,prevT2Lvl:ST.t2.lvl,prevT2A:ST.t2.aFail||0,prevRound:ST.roundLevel};
    // 升级
    var winNew=nextLevel(ST[win].lvl, r.up), loseNew=ST[lose].lvl;
    var nextBaseByRule = winNew; // 关键：下局 = 胜方升级后的级牌
    // A 规则
    var aNote='', finalWin=false, aTeam=null;
    var lastR=(r.mode==='4'?4:(r.mode==='6'?6:8)), winnerHasLast=(r.ranks.indexOf(lastR)>=0);
    if(ST.t1.lvl==='A' && ST.t2.lvl==='A') aTeam=win; else if(ST.t1.lvl==='A') aTeam='t1'; else if(ST.t2.lvl==='A') aTeam='t2';
    if(aTeam){
      if(aTeam===win){
        if(winnerHasLast){ // 胜方带末游 -> 不通关，失败+1
          ST[aTeam].aFail=(ST[aTeam].aFail||0)+1; aNote=((aTeam==='t1'?S.t1.name:S.t2.name))+' A级失败（胜方含末游）→ A'+ST[aTeam].aFail;
          if(ST[aTeam].aFail>=3){ 
            winNew='2'; // Reset winner to level 2
            ST[aTeam].aFail=0; 
            aNote+='｜累计3次失败，仅该队重置到2'; 
          } else {
            winNew=ST[win].lvl; // 本局不升级
          }
        }else{
          // Check strict mode - in strict mode, must win at YOUR OWN A level
          if(S.strictA && ST.roundLevel !== 'A'){
            // In strict mode, winning at other team's level doesn't count as 通关
            aNote=((aTeam==='t1'?S.t1.name:S.t2.name))+' A级胜利（但本局级牌为'+ST.roundLevel+'，需在自己的A级获胜才能通关）';
            // Still no upgrade, but no failure count increase
            winNew=ST[win].lvl;
          } else {
            // Either lenient mode, or strict mode and playing at A level
            finalWin=true; 
            aNote=((aTeam==='t1'?S.t1.name:S.t2.name))+' A级通关（胜方无末游'+(S.strictA?'，在自己的A级':'')+')';
          }
        }
      }else{
        ST[aTeam].aFail=(ST[aTeam].aFail||0)+1; aNote=((aTeam==='t1'?S.t1.name:S.t2.name))+' A级失败（未取胜）→ A'+ST[aTeam].aFail;
        if(ST[aTeam].aFail>=3){ 
          // Reset the losing A-team to level 2
          if(aTeam === win) {
            winNew = '2';
          } else {
            loseNew = '2';
          }
          ST[aTeam].aFail=0; 
          aNote+='｜累计3次失败，仅该队重置到2'; 
        }
      }
    }
    // 应用升级至队伍
    ST[win].lvl=winNew; ST[lose].lvl=loseNew;
    // 决定并保存"下局级牌"
    if(S.autoNext || finalWin){ 
      ST.roundLevel = String(nextBaseByRule); // Move to next round (winner's new level)
      ST.nextRoundBase=null; 
      console.log('Auto advancing: roundLevel set to', ST.roundLevel, 'from', thisRound);
    }
    else { 
      ST.roundLevel = String(thisRound); // Stay at current round
      ST.nextRoundBase = String(nextBaseByRule); // But preview shows what next round would be
      console.log('Manual mode: roundLevel stays at', ST.roundLevel, 'next would be', ST.nextRoundBase);
    }
    // Build player ranking details for history
    var playerRankings = {};
    for (var rank in currentRanking) {
      var playerId = currentRanking[rank];
      var player = players.find(function(p) { return p.id === playerId; });
      if (player) {
        playerRankings[rank] = {
          id: player.id,
          name: player.name,
          emoji: player.emoji,
          team: player.team
        };
      }
    }
    
    // 写历史
    var row={ts:now(),mode:r.mode,combo:'('+r.ranks.join(',')+')',up:r.up,win:(win==='t1'?S.t1.name:S.t2.name),t1:ST.t1.lvl,t2:ST.t2.lvl,round:thisRound,aNote:aNote,winKey:win,prevT1Lvl:snap.prevT1Lvl,prevT1A:snap.prevT1A,prevT2Lvl:snap.prevT2Lvl,prevT2A:snap.prevT2A,prevRound:snap.prevRound,playerRankings:playerRankings};
    ST.hist.push(row); save(KEY_ST,ST);
    // Update player stats
    updatePlayerStats();
    // Clear ranking for next round
    currentRanking = {};
    input.value = ''; // Clear the input as well
    renderTeams(); renderHistory(); calc();
    renderRankingArea();
    applyTip.textContent = finalWin ? ('🎉 '+row.win+' A级通关！') : (S.autoNext ? '已应用，已进入下一局（本局→下局：'+thisRound+'→'+nextBaseByRule+'）。' : '已应用。下局级牌：'+nextBaseByRule+'。');
    
    // Show victory modal if A-level was won
    if (finalWin) {
      showVictoryModal(row.win);
    }
    
    // Clear ranking for next round if auto-apply is enabled
    if (S.autoApply) {
      clearRanking();
    }
  }

  function doAdvance(){ if(ST.nextRoundBase){ ST.roundLevel = ST.nextRoundBase; ST.nextRoundBase=null; save(KEY_ST,ST); renderTeams(); calc(); applyTip.textContent='已进入下一局'; } else { applyTip.textContent='没有待进入的下一局（或已自动进入）。'; } }

  // Rollback/undo/reset
  function rollbackTo(index){ if(index<0||index>=ST.hist.length) return; var h=ST.hist[index]; if(!confirm('回滚到第 '+(index+1)+' 局之前？')) return; ST.t1.lvl=h.prevT1Lvl; ST.t1.aFail=h.prevT1A||0; ST.t2.lvl=h.prevT2Lvl; ST.t2.aFail=h.prevT2A||0; ST.roundLevel=h.prevRound||'2'; ST.nextRoundBase=null; ST.hist=ST.hist.slice(0,index); save(KEY_ST,ST); renderTeams(); renderHistory(); calc(); applyTip.textContent='已回滚。'; }
  function undoLast(){ if(!ST.hist.length){ alert('没有可撤销的记录'); return; } rollbackTo(ST.hist.length-1); }
  function resetAll(){ 
    if(!confirm('重置整场？')) return; 
    // Reset state to initial values
    ST={t1:{lvl:'2',aFail:0},t2:{lvl:'2',aFail:0},hist:[],roundLevel:'2',nextRoundBase:null}; 
    save(KEY_ST,ST); 
    
    // Clear player-related state
    selected=[]; 
    input.value=''; 
    playerStats = {}; 
    save('gd_player_stats', {}); 
    currentRanking = {};
    
    // Re-render everything
    renderTeams(); 
    renderHistory(); 
    calc(); 
    renderStatistics(); 
    renderRankingArea();
    generatePlayers(); // Regenerate players to ensure clean state
    
    applyTip.textContent='已重置整场比赛';
    
    // Close victory modal if it's open
    closeVictoryModal();
  }

  // Victory Modal
  function showVictoryModal(teamName) {
    var modal = $('victoryModal');
    var modalContent = modal.querySelector('div');
    var teamNameEl = $('victoryTeamName');
    
    // Determine which team won and get their color
    var winningTeamColor = '';
    if (teamName === S.t1.name) {
      winningTeamColor = S.t1.color;
    } else if (teamName === S.t2.name) {
      winningTeamColor = S.t2.color;
    }
    
    // Update modal content
    teamNameEl.textContent = teamName;
    teamNameEl.style.color = winningTeamColor;
    
    // Update modal border color
    modalContent.style.borderColor = winningTeamColor;
    modalContent.style.boxShadow = '0 0 30px ' + winningTeamColor + '40';
    
    modal.style.display = 'flex';
  }
  
  function closeVictoryModal() {
    var modal = $('victoryModal');
    modal.style.display = 'none';
  }
  
  // Make functions globally accessible
  window.closeVictoryModal = closeVictoryModal;
  window.exportTXT = exportTXT;
  window.exportCSV = exportCSV;
  window.exportLongPNG = exportLongPNG;
  window.resetAll = resetAll;
  
  // Exports
  var exportTip=$('exportTip');
  function exportTXT(){ 
    var lines=['掼蛋战绩导出（v8.0）','================',
      '当前本局级牌：'+ST.roundLevel,
      '下局预览：'+(ST.nextRoundBase||'—'),
      (S.t1.name||'队1')+'级牌：'+ST.t1.lvl+'｜A'+(ST.t1.aFail||0)+'/3',
      (S.t2.name||'队2')+'级牌：'+ST.t2.lvl+'｜A'+(ST.t2.aFail||0)+'/3',
      'A级规则：'+(S.strictA?'严格模式':'宽松模式'),
      '',
      '#  时间 | 人数 | 胜方组合 | 玩家排名 | 升级情况 | 胜队 | '+S.t1.name+'级 | '+S.t2.name+'级 | 本局级 | A说明'
    ]; 
    for(var i=0;i<ST.hist.length;i++){ 
      var h=ST.hist[i]; 
      // Build player ranking string
      var playerRankStr = '';
      if(h.playerRankings){
        var rankParts = [];
        for(var r=1; r<=parseInt(h.mode); r++){
          if(h.playerRankings[r]){
            var p = h.playerRankings[r];
            rankParts.push(p.emoji+p.name);
          }
        }
        playerRankStr = rankParts.join(' ');
      }
      var upgradeStr = h.up ? (h.win + ' 升' + h.up + '级') : '不升级';
      lines.push([i+1,h.ts,h.mode,h.combo,playerRankStr,upgradeStr,h.win,h.t1,h.t2,h.round,h.aNote].join(' | ')); 
    } 
    var blob=new Blob([lines.join('\n')],{type:'text/plain;charset=utf-8'}); 
    var a=document.createElement('a'); 
    a.href=URL.createObjectURL(blob); 
    a.download='掼蛋战绩_v8.txt'; 
    a.click(); 
    exportTip.textContent='已导出 TXT'; 
    setTimeout(function(){exportTip.textContent='';},1200); 
  }
  function csvEscape(v){ var s=String(v).replace(/"/g,'""'); if(s.search(/[",\n]/)>=0) s='"'+s+'"'; return s; }
  function exportCSV(){ 
    var rows=[['#','时间','人数','胜方组合','玩家排名','升级情况','胜队',S.t1.name+'级',S.t2.name+'级','本局级','A说明','A级规则']]; 
    for(var i=0;i<ST.hist.length;i++){ 
      var h=ST.hist[i]; 
      // Build player ranking string
      var playerRankStr = '';
      if(h.playerRankings){
        var rankParts = [];
        for(var r=1; r<=parseInt(h.mode); r++){
          if(h.playerRankings[r]){
            var p = h.playerRankings[r];
            rankParts.push(p.emoji+p.name);
          }
        }
        playerRankStr = rankParts.join(' ');
      }
      var upgradeStr = h.up ? (h.win + ' 升' + h.up + '级') : '不升级';
      rows.push([i+1,h.ts,h.mode,h.combo,playerRankStr,upgradeStr,h.win,h.t1,h.t2,h.round,h.aNote,S.strictA?'严格':'宽松']); 
    } 
    var lines=rows.map(function(r){ return r.map(csvEscape).join(','); }).join('\n'); 
    var blob=new Blob([lines],{type:'text/csv;charset=utf-8'}); 
    var a=document.createElement('a'); 
    a.href=URL.createObjectURL(blob); 
    a.download='掼蛋战绩_v8.csv'; 
    a.click(); 
    exportTip.textContent='已导出 CSV'; 
    setTimeout(function(){exportTip.textContent='';},1200); 
  }
  function exportLongPNG(){ 
    var W=2200, headH=220, rowH=40, n=ST.hist.length, H=headH+(n+1)*rowH+80; 
    longCnv.width=W; longCnv.height=H; 
    lctx.fillStyle='#0b0b0c'; lctx.fillRect(0,0,W,H); 
    lctx.fillStyle='#f5f6f8'; 
    lctx.font='bold 48px Arial'; 
    lctx.fillText('掼蛋战绩总览 v8.0',40,70); 
    lctx.font='20px Arial'; 
    lctx.fillStyle='#b4b8bf'; 
    lctx.fillText('当前本局级牌：'+ST.roundLevel+'｜下局预览：'+(ST.nextRoundBase||'—')+'｜A级规则：'+(S.strictA?'严格模式':'宽松模式'),40,110); 
    lctx.fillText('队伍：'+S.t1.name+'（'+ST.t1.lvl+'，A'+(ST.t1.aFail||0)+'/3） | '+S.t2.name+'（'+ST.t2.lvl+'，A'+(ST.t2.aFail||0)+'/3）',40,140); 
    lctx.fillText('生成时间：'+now(),40,170); 
    
    var cols=['#','时间','人数','胜方组合','玩家排名','升级','胜队',S.t1.name+'级',S.t2.name+'级','本局级','A说明']; 
    var xs=[40,80,240,300,440,700,800,900,1000,1100,1200]; 
    lctx.font='bold 20px Arial'; 
    lctx.fillStyle='#e6b800'; 
    for(var c=0;c<cols.length;c++) lctx.fillText(cols[c], xs[c], headH); 
    
    lctx.font='14px Arial'; 
    for(var i=0;i<n;i++){ 
      var h=ST.hist[i], y=headH+(i+1)*rowH; 
      
      // Add row background color based on winning team
      var winColor = h.winKey === 't1' ? S.t1.color : S.t2.color;
      lctx.fillStyle = winColor + '10'; // Very light background
      lctx.fillRect(0, y - rowH + 10, W, rowH);
      
      // Build player ranking string with emoji and names
      var playerRankStr = '';
      if(h.playerRankings) {
        var rankParts = [];
        for(var r=1; r<=8; r++) {
          if(h.playerRankings[r]) {
            var p = h.playerRankings[r];
            rankParts.push(p.emoji + p.name);
          }
        }
        playerRankStr = rankParts.join(' ');
      }
      
      var upgradeStr = h.up ? (h.win + ' 升' + h.up) : '不升';
      var vals=[i+1,h.ts.substring(0,16),h.mode,h.combo,playerRankStr,upgradeStr,h.win,h.t1,h.t2,h.round,h.aNote||'']; 
      
      // Set text color
      lctx.fillStyle='#f5f6f8';
      
      for(var j=0;j<vals.length;j++) {
        var text = String(vals[j]);
        // Wrap long A notes
        if(j === 10 && text.length > 50) {
          var maxWidth = 800;
          var words = text.split(' ');
          var line = '';
          var lineY = y;
          for(var w = 0; w < words.length; w++) {
            var testLine = line + words[w] + ' ';
            var metrics = lctx.measureText(testLine);
            if (metrics.width > maxWidth && w > 0) {
              lctx.fillText(line, xs[j], lineY);
              line = words[w] + ' ';
              lineY += 15;
            } else {
              line = testLine;
            }
          }
          lctx.fillText(line, xs[j], lineY);
        } else {
          lctx.fillText(text, xs[j], y);
        }
      }
    } 
    var a=document.createElement('a'); 
    a.href=longCnv.toDataURL('image/png'); 
    a.download='掼蛋战绩_v8.png'; 
    a.click(); 
  }

  // Events
  on(modeSel,'change', function(){ selected=[]; input.value=''; updateRuleHint(); calc(); generatePlayers(); });
  on(applyBtn,'click', applyResult); on(advanceBtn,'click', doAdvance);
  on($('undo'),'click', undoLast);
  on($('exportTxt'),'click', exportTXT); on($('exportCsv'),'click', exportCSV); on($('exportLongPng'),'click', exportLongPNG);
  on($('resetMatch'),'click', resetAll);
  
  // Player system events
  on($('generatePlayers'),'click', generatePlayers);
  on($('shuffleTeams'),'click', shuffleTeams);
  on($('clearRanking'),'click', clearRanking);
  on($('randomRanking'),'click', randomizeRanking);
  on($('manualCalc'),'click', function() {
    // Force rebuild currentRanking from what's actually in the slots
    var area = $('rankingArea');
    var slots = area.querySelectorAll('.rank-slot');
    var newRanking = {};
    
    slots.forEach(function(slot) {
      var rank = parseInt(slot.dataset.rank);
      var playerTile = slot.querySelector('.ranking-player-tile');
      if (playerTile) {
        var playerId = playerTile.dataset.playerId;
        if (playerId) {
          newRanking[rank] = playerId;
        }
      }
    });
    
    console.log('Rebuilt ranking from UI:', newRanking);
    currentRanking = newRanking;
    
    // Now calculate
    calculateFromRanking();
    
    // Also trigger apply if calculation was successful
    var r = calc();
    if (r.ok) {
      applyResult();
    }
  });

  function syncSelectedFromInput(){ var need=(modeSel.value==='4'?2:(modeSel.value==='6'?3:4)); var pr=parseRanks(input.value, need); selected=pr.ok?pr.ranks.slice():[]; }

  // Init
  generatePlayers();
  setupDropZones();
  renderStatistics();
  // Set initial state
  headline.textContent = '等待排名';
  explain.textContent = '请将玩家拖到排名位置';
  if (winnerDisplay) winnerDisplay.textContent = '—';
})();
</script>

<footer style="text-align: center; padding: 20px; margin-top: 40px; border-top: 1px solid #ddd; color: #666; font-size: 14px;">
  Made with ❤️ by Xingfan Xia, Claude Opus 4.1 & GPT-5 | 
  <a href="https://github.com/xingfanxia/guandan_calc" target="_blank" style="color: #4078c0; text-decoration: none;">
    GitHub
  </a>
</footer>

</body>
</html>
