<!DOCTYPE html>
<html lang="zh-CN">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover">
<title>æ¼è›‹å‡çº§è®¡ç®—å™¨ v8.0ï¼ˆç©å®¶ç³»ç»Ÿï¼‰</title>
<meta name="theme-color" content="#0b0b0c">
<style>
:root{ --bg:#0b0b0c; --card:#16171b; --ink:#f5f6f8; --muted:#b4b8bf; --stroke:#2a2d35; --chip:#24262c; --accent:#e6b800; }
*{box-sizing:border-box} body{margin:0;background:var(--bg);color:var(--ink);font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,"Helvetica Neue",Arial,"Noto Sans","PingFang SC","Hiragino Sans GB","Microsoft YaHei",sans-serif;-webkit-font-smoothing:antialiased}
.wrap{max-width:1150px;margin:0 auto;padding:16px}
.card{background:var(--card);border-radius:14px;padding:16px;margin:12px 0;box-shadow:0 6px 24px rgba(0,0,0,.25)}
h1{font-size:22px;margin:8px 0 4px} h3{margin:0 0 8px 0}
.small{font-size:12px}.muted{color:var(--muted)} .row{display:flex;gap:10px;flex-wrap:wrap;align-items:center}
input[type=text],input[type=number],input[type=color],select,button{background:#1f2229;color:var(--ink);border:1px solid var(--stroke);border-radius:12px;padding:10px 12px;font-size:16px}
input[type=text]{background:#0f1115;border-radius:10px}
button{cursor:pointer} button:hover{background:#232730}
.badge{display:inline-block;padding:3px 8px;border-radius:999px;background:var(--chip);margin-right:6px}
.counter{font-variant-numeric:tabular-nums}
.grid{display:grid;grid-template-columns:repeat(auto-fit,minmax(260px,1fr));gap:10px}
.gridN{display:grid;gap:8px}
.tile{display:flex;align-items:center;justify-content:center;height:52px;border-radius:12px;background:#24262c;border:1px solid var(--stroke);cursor:pointer;font-size:18px}
.tile.selected{background:#324056;border-color:#3e526b}
.team{display:flex;gap:10px;align-items:center;flex-wrap:wrap}
.team .chip{padding:4px 8px;border-radius:8px;background:#0f1115;border:1px solid var(--stroke)}
.table-wrap{overflow-x:auto;-webkit-overflow-scrolling:touch;border:1px solid var(--stroke);border-radius:10px}
.table{width:100%;border-collapse:separate;border-spacing:0;min-width:900px}
.table th,.table td{border-bottom:1px solid #2a2d35;padding:10px 8px;text-align:left;font-size:14px;white-space:nowrap}
.table th{position:sticky;top:0;background:var(--card);z-index:1}
.actions button{font-size:12px;padding:6px 8px}
.winbtn{position:relative;display:inline-flex;align-items:center;gap:8px;border-width:2px;font-weight:700;overflow:hidden;min-width:96px;transition:transform .08s ease,box-shadow .2s ease,background .15s ease,color .15s ease}
.winbtn:hover{transform:translateY(-1px);box-shadow:0 8px 20px rgba(0,0,0,.28)} .winbtn.active{box-shadow:0 0 0 2px rgba(255,255,255,.08) inset}
.ripple{position:absolute;border-radius:50%;transform:scale(0);opacity:.35;pointer-events:none;animation:ripple .6s ease-out}
@keyframes ripple{to{transform:scale(3);opacity:0}}
@media (max-width:768px){ .wrap{padding:12px} .grid{grid-template-columns:1fr} .gridN .tile{height:48px} #winBtnsWrap .winbtn{flex:1;justify-content:center} .btns-grid{display:grid;grid-template-columns:1fr 1fr;gap:8px} .table{min-width:720px} }
details{background:#131419;border:1px solid var(--stroke);border-radius:12px;padding:10px 12px}
details>summary{cursor:pointer;font-weight:600}
details+details{margin-top:8px}
.toggle{display:inline-flex;align-items:center;gap:6px}

/* Player System Styles */
.player-tile{display:inline-flex;align-items:center;gap:8px;padding:8px 12px;background:#1f2229;border:2px solid var(--stroke);border-radius:10px;cursor:move;user-select:none;-webkit-user-select:none;touch-action:none;transition:all .2s;margin:4px}
.player-tile:hover{transform:translateY(-2px);box-shadow:0 4px 12px rgba(0,0,0,.3)}
.player-tile.dragging{opacity:.5;transform:scale(0.95)}
.player-tile .emoji{font-size:20px}
.player-tile .name{font-size:14px;max-width:100px;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}
.player-tile input{background:transparent;border:none;color:var(--ink);font-size:14px;width:80px;padding:0;touch-action:auto;user-select:text;-webkit-user-select:text}

.team-drop-zone{min-height:80px;background:#0f1115;border:2px dashed var(--stroke);border-radius:12px;padding:12px;margin:8px 0;display:flex;flex-wrap:wrap;gap:8px;transition:all .2s}
.team-drop-zone.drag-over{border-color:var(--accent);background:rgba(230,184,0,.05)}
.team-drop-zone .label{width:100%;font-size:12px;color:var(--muted);margin-bottom:4px}

.rank-slot{display:inline-flex;align-items:center;justify-content:center;min-width:150px;min-height:60px;background:#1f2229;border:2px solid var(--stroke);border-radius:12px;margin:8px;padding:8px;transition:all .2s;position:relative}
.rank-slot.drag-over{border-color:var(--accent);background:rgba(230,184,0,.1)}

/* Touch-specific styles for better mobile UX */
@media (hover: none) and (pointer: coarse) {
  .player-tile, .ranking-player-tile {
    padding: 10px 14px;
    min-height: 44px; /* iOS touch target size */
    position: relative;
  }
  .rank-slot {
    min-height: 70px;
    min-width: 170px;
  }
  .team-drop-zone {
    min-height: 100px;
  }
  /* Visual hint for long press */
  .player-tile::after, .ranking-player-tile::after {
    content: 'â‹®â‹®';
    position: absolute;
    right: 4px;
    top: 50%;
    transform: translateY(-50%);
    color: var(--muted);
    font-size: 10px;
    opacity: 0.5;
  }
}
.rank-slot .rank-number{position:absolute;top:4px;left:8px;font-size:18px;font-weight:bold;color:var(--accent)}
.rank-slot.filled{background:#24262c}

.ranking-area{display:grid;grid-template-columns:repeat(auto-fit,minmax(180px,1fr));gap:12px;margin:16px 0}

.stats-table{width:100%;margin-top:12px}
.stats-table th{background:var(--chip);padding:8px;text-align:left;font-size:14px}
.stats-table td{padding:8px;font-size:14px;border-bottom:1px solid var(--stroke)}
.stats-table .emoji{font-size:18px;margin-right:4px}

.player-setup{margin-bottom:16px}
.unassigned-players{display:flex;flex-wrap:wrap;gap:8px;min-height:50px;padding:12px;background:#0f1115;border-radius:12px;margin:12px 0}

/* Player Pool for Ranking */
.player-pool-section{margin:16px 0}
.player-pool{display:flex;flex-wrap:wrap;gap:8px;min-height:60px;padding:12px;background:#0f1115;border:2px dashed var(--stroke);border-radius:12px;margin:8px 0}
.player-pool.drag-over{border-color:var(--accent);background:rgba(230,184,0,.05)}
.player-pool .player-tile{cursor:grab}
.player-pool .player-tile:active{cursor:grabbing}

/* Simplified player tiles for ranking */
.ranking-player-tile{display:inline-flex;align-items:center;gap:6px;padding:6px 10px;background:#1f2229;border:2px solid var(--stroke);border-radius:8px;cursor:move;user-select:none;-webkit-user-select:none;touch-action:none;transition:all .2s;font-size:14px}
.ranking-player-tile:hover{transform:translateY(-1px);box-shadow:0 2px 8px rgba(0,0,0,.2)}
.ranking-player-tile.dragging{opacity:.5;transform:scale(0.95)}
.ranking-player-tile .emoji{font-size:16px}
.ranking-player-tile .name{font-size:13px}

.ranking-section{margin-top:20px}
.ranking-area{display:grid;grid-template-columns:repeat(auto-fill,minmax(160px,1fr));gap:10px;margin:12px 0}
</style>
</head>
<body>
<div class="wrap">
  <h1>æ¼è›‹å‡çº§è®¡ç®—å™¨ v8.0 <span class="badge">ç©å®¶ç³»ç»Ÿ</span></h1>

  <!-- ç©å®¶è®¾ç½® -->
  <div class="card">
    <h3>ç©å®¶è®¾ç½®</h3>
    <div class="row">
      <label for="mode">äººæ•°ï¼š</label>
      <select id="mode"><option value="4">4 äºº</option><option value="6">6 äºº</option><option value="8" selected>8 äºº</option></select>
      <button id="generatePlayers">ç”Ÿæˆç©å®¶</button>
      <button id="shuffleTeams">éšæœºåˆ†é…é˜Ÿä¼</button>
    </div>
    <div class="unassigned-players" id="unassignedPlayers">
      <div class="small muted" style="width:100%">ç‚¹å‡»"ç”Ÿæˆç©å®¶"å¼€å§‹</div>
    </div>
    
    <div class="grid">
      <div>
        <h4 id="team1Label">è“é˜Ÿ</h4>
        <div class="team-drop-zone" id="team1Zone" data-team="1">
          <div class="label">æ‹–æ‹½ç©å®¶åˆ°è¿™é‡Œåˆ†é…é˜Ÿä¼</div>
        </div>
      </div>
      <div>
        <h4 id="team2Label">çº¢é˜Ÿ</h4>
        <div class="team-drop-zone" id="team2Zone" data-team="2">
          <div class="label">æ‹–æ‹½ç©å®¶åˆ°è¿™é‡Œåˆ†é…é˜Ÿä¼</div>
        </div>
      </div>
    </div>
  </div>

  <!-- æœ¬å±€æ’å -->
  <div class="card">
    <h3>æœ¬å±€æ’å</h3>
    <div class="row">
      <div class="small">ä»…ğŸˆ¶1æ–¹å¯å‡çº§ï¼š</div><input type="checkbox" id="must1" checked>
      <span class="small muted" id="ruleHint"></span>
      <button id="clearRanking">æ¸…ç©ºæ’å</button>
      <button id="randomRanking">éšæœºæ’å</button>
      <button id="manualCalc">æ‰‹åŠ¨è®¡ç®—</button>
    </div>
    
    <!-- å¾…æ’åç©å®¶æ±  -->
    <div class="player-pool-section">
      <h4 class="small muted">å¾…æ’åç©å®¶</h4>
      <div class="player-pool" id="playerPool">
        <div class="small muted">è¯·å…ˆåˆ†é…ç©å®¶åˆ°é˜Ÿä¼</div>
      </div>
    </div>
    
    <!-- æ’åä½ç½® -->
    <div class="ranking-section">
      <h4 class="small muted">æ‹–æ‹½ç©å®¶åˆ°å¯¹åº”æ’å</h4>
      <div class="ranking-area" id="rankingArea">
        <!-- Ranking slots will be generated here -->
      </div>
    </div>
    
    <div class="small muted" id="tip">ä»ä¸Šæ–¹æ± ä¸­æ‹–æ‹½ç©å®¶åˆ°å¯¹åº”çš„æ’åä½ç½®</div>
  </div>

  <div class="grid">
    <div class="card">
      <h3>ç»“æœ</h3>
      <div id="headline">â€”</div>
      <div id="explain" class="small muted">ç­‰å¾…è¾“å…¥â€¦</div>
      <hr>
      <div class="row" id="winBtnsWrap">
        <span class="small">è·èƒœé˜Ÿï¼š</span>
        <span id="winnerDisplay" style="font-weight:bold">â€”</span>
        <button id="apply">åº”ç”¨ç»“æœåˆ°æˆ˜ç»©</button>
        <button id="advance" title="å°†æœ¬å±€çº§ç‰Œæ¨è¿›åˆ°é¢„è§ˆçš„ä¸‹ä¸€å±€">è¿›å…¥ä¸‹ä¸€å±€</button>
      </div>
      <div class="small muted">
        A å±€è§„åˆ™ï¼šèƒœæ–¹å¸¦æœ«æ¸¸â†’æœ¬å±€èƒœä½†ä¸é€šå…³ï¼Œå¤±è´¥æ•°+1ï¼›Aè¿è´¥åˆ°3ï¼ˆA3ï¼‰â†’ä»…è¯¥é˜Ÿå›2ã€‚<br>
        ä¸¥æ ¼æ¨¡å¼ï¼šå¿…é¡»åœ¨è‡ªå·±çš„Açº§è·èƒœæ‰èƒ½é€šå…³ | å®½æ¾æ¨¡å¼ï¼šä»»ä½•æ—¶å€™Açº§è·èƒœéƒ½å¯é€šå…³
      </div>
      <div class="small muted toggle" style="margin-top:6px;">
        <input type="checkbox" id="autoNext"> <label for="autoNext">åº”ç”¨åè‡ªåŠ¨è¿›å…¥ä¸‹ä¸€å±€</label>
        <br>
        <input type="checkbox" id="autoApply"> <label for="autoApply" style="color:#4ade80;font-weight:bold">âœ… æ’åå®Œæˆåè‡ªåŠ¨åº”ç”¨ç»“æœï¼ˆå‡çº§é˜Ÿä¼ï¼‰</label>
        <br>
        <input type="checkbox" id="strictA" checked> <label for="strictA" style="color:#f59e0b">ğŸ¯ ä¸¥æ ¼Açº§è§„åˆ™ï¼ˆå¿…é¡»åœ¨è‡ªå·±çš„Açº§è·èƒœæ‰èƒ½é€šå…³ï¼‰</label>
      </div>
      <span class="small muted" id="applyTip"></span>
    </div>

    <div class="card">
      <h3>é˜Ÿä¼</h3>
      <div class="team">
        <span class="chip" id="t1NameChip"><b>è“é˜Ÿ</b></span><span class="chip">çº§ç‰Œï¼š<b id="t1Lvl">2</b></span><span class="chip">Aå¤±è´¥ï¼š<b id="t1A">0</b>/3</span><span class="chip">AçŠ¶æ€ï¼š<b id="t1AState">â€”</b></span>
      </div>
      <div class="team">
        <span class="chip" id="t2NameChip"><b>çº¢é˜Ÿ</b></span><span class="chip">çº§ç‰Œï¼š<b id="t2Lvl">2</b></span><span class="chip">Aå¤±è´¥ï¼š<b id="t2A">0</b>/3</span><span class="chip">AçŠ¶æ€ï¼š<b id="t2AState">â€”</b></span>
      </div>
      <hr>
      <div class="team">
        <span class="chip">æœ¬å±€çº§ç‰Œï¼š<b id="curRoundLvl">2</b></span>
        <span class="chip">ä¸‹å±€çº§ç‰Œï¼ˆé¢„è§ˆï¼‰ï¼š<b id="nextRoundPreview">-</b></span>
      </div>
    </div>
  </div>

  <div class="card">
    <h3>è‡ªå®šä¹‰è§„åˆ™</h3>
    <div class="grid">
      <details open><summary>4äººå‡çº§è¡¨</summary>
        <div class="row" style="margin-top:8px;">
          <div>(1,2)= <input type="number" id="c4_12" value="3" min="0" max="5"></></div>
          <div>(1,3)= <input type="number" id="c4_13" value="2" min="0" max="5"></></div>
          <div>(1,4)= <input type="number" id="c4_14" value="1" min="0" max="5"></></div>
          <button id="save4">ä¿å­˜4äººè®¾ç½®</button>
        </div>
      </details>
      <details><summary>6äººé˜ˆå€¼ & åˆ†å€¼</summary>
        <div class="row" style="margin-top:8px;">
          <div>å‡3çº§â‰¥ <input type="number" id="t6_3" value="7"></div>
          <div>å‡2çº§â‰¥ <input type="number" id="t6_2" value="4"></div>
          <div>å‡1çº§â‰¥ <input type="number" id="t6_1" value="1"></div>
        </div>
        <div class="row" style="margin-top:8px;flex-wrap:wrap;gap:12px;">
          <div>1ååˆ† <input type="number" id="p6_1" value="5" style="width:80px"></div>
          <div>2ååˆ† <input type="number" id="p6_2" value="4" style="width:80px"></div>
          <div>3ååˆ† <input type="number" id="p6_3" value="3" style="width:80px"></div>
          <div>4ååˆ† <input type="number" id="p6_4" value="3" style="width:80px"></div>
          <div>5ååˆ† <input type="number" id="p6_5" value="1" style="width:80px"></div>
          <div>6ååˆ† <input type="number" id="p6_6" value="0" style="width:80px"></div>
        </div>
        <div class="row" style="margin-top:8px;"><button id="save6">ä¿å­˜6äººè®¾ç½®</button></div>
      </details>
      <details><summary>8äººé˜ˆå€¼ & åˆ†å€¼</summary>
        <div class="row" style="margin-top:8px;">
          <div>å‡3çº§â‰¥ <input type="number" id="t8_3" value="11"></div>
          <div>å‡2çº§â‰¥ <input type="number" id="t8_2" value="6"></div>
          <div>å‡1çº§â‰¥ <input type="number" id="t8_1" value="1"></div>
        </div>
        <div class="row" style="margin-top:8px;flex-wrap:wrap;gap:12px;">
          <div>1ååˆ† <input type="number" id="p8_1" value="7" style="width:80px"></div>
          <div>2ååˆ† <input type="number" id="p8_2" value="6" style="width:80px"></div>
          <div>3ååˆ† <input type="number" id="p8_3" value="5" style="width:80px"></div>
          <div>4ååˆ† <input type="number" id="p8_4" value="4" style="width:80px"></div>
          <div>5ååˆ† <input type="number" id="p8_5" value="3" style="width:80px"></div>
          <div>6ååˆ† <input type="number" id="p8_6" value="2" style="width:80px"></div>
          <div>7ååˆ† <input type="number" id="p8_7" value="1" style="width:80px"></div>
          <div>8ååˆ† <input type="number" id="p8_8" value="0" style="width:80px"></div>
        </div>
        <div class="row" style="margin-top:8px;"><button id="save8">ä¿å­˜8äººè®¾ç½®</button></div>
      </details>
    </div>
  </div>

  <div class="card">
    <h3>å†å²æˆ˜ç»©</h3>
    <div class="table-wrap">
      <table class="table" id="hist">
        <thead><tr>
          <th>#</th><th>æ—¶é—´</th><th>äººæ•°</th><th>èƒœæ–¹ç»„åˆ</th><th>ç©å®¶æ’å</th><th>å‡çº§æƒ…å†µ</th><th>èƒœé˜Ÿ</th>
          <th><span id="hT1"></span>çº§ç‰Œ</th><th><span id="hT2"></span>çº§ç‰Œ</th><th>æœ¬å±€çº§ç‰Œ</th><th>Aè¯´æ˜</th><th>æ“ä½œ</th>
        </tr></thead>
        <tbody id="histBody"></tbody>
      </table>
    </div>
    <div class="row btns-grid" style="margin-top:10px;">
      <button id="undo">æ’¤é”€ä¸Šä¸€å±€</button>
      <button id="exportTxt">å¯¼å‡º TXT</button>
      <button id="exportCsv">å¯¼å‡º CSV</button>
      <button id="exportLongPng">å¯¼å‡º é•¿å›¾ PNG</button>
      <button id="resetMatch" style="border-color:#5b1e1e;color:#ffb3b3">é‡ç½®æ•´åœº</button>
      <span id="exportTip" class="small muted" style="grid-column:1/-1"></span>
    </div>
  </div>

  <!-- ç©å®¶ç»Ÿè®¡ -->
  <div class="grid">
    <div class="card">
      <h3>ç©å®¶æ’åç»Ÿè®¡</h3>
      <table class="stats-table">
        <thead>
          <tr>
            <th>ç©å®¶</th>
            <th>é˜Ÿä¼</th>
            <th>åœºæ¬¡</th>
            <th>å¹³å‡æ’å</th>
            <th>æ‹¿1æ¬¡æ•°</th>
            <th>å«åº•æ¬¡æ•°</th>
          </tr>
        </thead>
        <tbody id="playerStatsBody">
          <tr><td colspan="6" class="muted small">æš‚æ— æ•°æ®</td></tr>
        </tbody>
      </table>
    </div>

    <div class="card">
      <h3>é˜Ÿä¼MVP & Burden</h3>
      <div id="team1Stats" style="margin-bottom:16px">
        <h4 id="team1StatsTitle">è“é˜Ÿ</h4>
        <div class="row">
          <span class="badge">MVP: <span id="team1MVP">â€”</span></span>
          <span class="badge">Burden: <span id="team1Burden">â€”</span></span>
        </div>
      </div>
      <div id="team2Stats">
        <h4 id="team2StatsTitle">çº¢é˜Ÿ</h4>
        <div class="row">
          <span class="badge">MVP: <span id="team2MVP">â€”</span></span>
          <span class="badge">Burden: <span id="team2Burden">â€”</span></span>
        </div>
      </div>
    </div>
  </div>
</div>

<canvas id="longCnv" width="1200" height="1600" style="display:none"></canvas>

<!-- Victory Modal -->
<div id="victoryModal" style="display:none; position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.8); z-index:9999; align-items:center; justify-content:center;">
  <div style="background:#1a1b1c; border-radius:16px; padding:32px; max-width:500px; text-align:center; border:3px solid #4ade80; transition: all 0.3s ease;">
    <h1 style="color:#fff; font-size:36px; margin:0 0 16px 0;">ğŸ‰ Açº§é€šå…³ï¼ğŸ‰</h1>
    <h2 id="victoryTeamName" style="font-size:48px; margin:0 0 24px 0; font-weight:bold; text-shadow: 0 0 20px currentColor;"></h2>
    <p style="color:#999; font-size:18px; margin-bottom:32px;">æ­å–œå®Œæˆæ‰€æœ‰çº§åˆ«çš„æŒ‘æˆ˜ï¼</p>
    
    <div style="display:flex; gap:16px; justify-content:center; flex-wrap:wrap;">
      <button onclick="exportTXT()" style="padding:12px 24px; background:#3b82f6; color:white; border:none; border-radius:8px; font-size:16px; cursor:pointer;">
        ğŸ“„ å¯¼å‡º TXT
      </button>
      <button onclick="exportCSV()" style="padding:12px 24px; background:#3b82f6; color:white; border:none; border-radius:8px; font-size:16px; cursor:pointer;">
        ğŸ“Š å¯¼å‡º CSV
      </button>
      <button onclick="exportLongPNG()" style="padding:12px 24px; background:#3b82f6; color:white; border:none; border-radius:8px; font-size:16px; cursor:pointer;">
        ğŸ–¼ï¸ å¯¼å‡ºé•¿å›¾
      </button>
      <button onclick="resetAll()" style="padding:12px 24px; background:#ef4444; color:white; border:none; border-radius:8px; font-size:16px; cursor:pointer;">
        ğŸ”„ é‡ç½®æ•´åœº
      </button>
      <button onclick="closeVictoryModal()" style="padding:12px 24px; background:#666; color:white; border:none; border-radius:8px; font-size:16px; cursor:pointer;">
        å…³é—­
      </button>
    </div>
  </div>
</div>

<script>
(function(){
  function $(id){ return document.getElementById(id); }
  function on(el,ev,fn){ el.addEventListener?el.addEventListener(ev,fn):el.attachEvent('on'+ev,fn); }
  function now(){ return new Date().toLocaleString(); }

  var modeSel=$('mode'), input = { value: '' }, must1=$('must1'), ruleHint=$('ruleHint');
  var tip=$('tip');
  var headline=$('headline'), explain=$('explain'), applyBtn=$('apply'), applyTip=$('applyTip'), advanceBtn=$('advance');
  var winnerDisplay=$('winnerDisplay');
  var autoNext=$('autoNext'), autoApply=$('autoApply'), strictA=$('strictA');
  var t1Lvl=$('t1Lvl'), t2Lvl=$('t2Lvl'), t1A=$('t1A'), t2A=$('t2A'), t1AState=$('t1AState'), t2AState=$('t2AState');
  var t1NameChip=$('t1NameChip'), t2NameChip=$('t2NameChip');
  var curRoundLvl=$('curRoundLvl'), nextRoundPreview=$('nextRoundPreview');
  var hT1=$('hT1'), hT2=$('hT2');
  var longCnv=$('longCnv'), lctx=longCnv.getContext('2d');
  var selected=[];

  // Storage
  var KEY_S='gd_v7_5_1_settings', KEY_ST='gd_v7_5_1_state';
  function load(key, def){ try{ var v=localStorage.getItem(key); return v?JSON.parse(v):def; }catch(e){ return def; } }
  function save(key, v){ try{ localStorage.setItem(key, JSON.stringify(v)); }catch(e){} }

  // Settings
  var S=load(KEY_S,{});
  if(!S.c4){ S.c4={'1,2':3,'1,3':2,'1,4':1}; }
  if(!S.t6){ S.t6={g3:7,g2:4,g1:1}; }
  if(!S.p6){ S.p6={1:5,2:4,3:3,4:3,5:1,6:0}; }
  if(!S.t8){ S.t8={g3:11,g2:6,g1:1}; }
  if(!S.p8){ S.p8={1:7,2:6,3:5,4:4,5:3,6:2,7:1,8:0}; }
  if(typeof S.must1==='undefined'){ S.must1=true; }
  if(typeof S.autoNext==='undefined'){ S.autoNext=true; } // Default to auto-advance
  if(typeof S.autoApply==='undefined'){ S.autoApply=true; } // Default to true for better UX
  if(typeof S.strictA==='undefined'){ S.strictA=true; } // Default to strict mode
  if(!S.t1){ S.t1={name:'è“é˜Ÿ', color:'#3b82f6'}; }
  if(!S.t2){ S.t2={name:'çº¢é˜Ÿ', color:'#ef4444'}; }

  // State
  var ST=load(KEY_ST,{});
  if(!ST.t1){ ST.t1={lvl:'2',aFail:0}; }
  if(!ST.t2){ ST.t2={lvl:'2',aFail:0}; }
  if(!ST.hist){ ST.hist=[]; }
  if(!ST.roundLevel){ ST.roundLevel='2'; }
  if(!ST.nextRoundBase){ ST.nextRoundBase=null; } // å…³é”®ï¼šä¸‹ä¸€å±€åº”å½“æ‰“çš„çº§ç‰Œ

  var winner='t1';

  // Player System Variables
  var players = [];
  var playerStats = {};
  var currentRanking = {};
  var draggedPlayer = null;
  var touchDraggedElement = null; // For touch dragging
  var touchClone = null; // Clone element for visual feedback during touch
  var touchStartTimer = null; // Timer for delayed drag start
  var touchStartPos = null; // Initial touch position
  var animalEmojis = ['ğŸ¶','ğŸ±','ğŸ­','ğŸ¹','ğŸ°','ğŸ¦Š','ğŸ»','ğŸ¼','ğŸ¨','ğŸ¯','ğŸ¦','ğŸ®','ğŸ·','ğŸ¸','ğŸµ','ğŸ”','ğŸ§','ğŸ¦','ğŸ¤','ğŸ¦†','ğŸ¦…','ğŸ¦‰','ğŸ¦‡','ğŸº','ğŸ—','ğŸ´','ğŸ¦„','ğŸ','ğŸ›','ğŸ¦‹','ğŸŒ','ğŸ','ğŸœ','ğŸ¦Ÿ','ğŸ¦—','ğŸ•·ï¸','ğŸ¦‚','ğŸ¢','ğŸ','ğŸ¦','ğŸ¦–','ğŸ¦•','ğŸ™','ğŸ¦‘','ğŸ¦','ğŸ¦€','ğŸ¡','ğŸ ','ğŸŸ','ğŸ¬','ğŸ³','ğŸ‹','ğŸ¦ˆ'];
  
  // Touch event helper functions
  function handleTouchStart(e, player) {
    // Don't start drag if touching an input field
    if (e.target.tagName === 'INPUT') {
      return; // Allow normal input interaction
    }
    
    var touch = e.touches[0];
    var tile = e.currentTarget;
    
    // Store initial touch position
    touchStartPos = { x: touch.clientX, y: touch.clientY };
    
    // Set up delayed drag start (long press)
    touchStartTimer = setTimeout(function() {
      // Start drag after delay
      e.preventDefault();
      draggedPlayer = player;
      touchDraggedElement = tile;
      
      // Create clone for visual feedback
      touchClone = tile.cloneNode(true);
      touchClone.style.position = 'fixed';
      touchClone.style.zIndex = '1000';
      touchClone.style.opacity = '0.8';
      touchClone.style.pointerEvents = 'none';
      touchClone.style.transform = 'scale(1.1)';
      touchClone.classList.add('dragging');
      document.body.appendChild(touchClone);
      
      // Position clone at touch point
      touchClone.style.left = (touch.clientX - tile.offsetWidth/2) + 'px';
      touchClone.style.top = (touch.clientY - tile.offsetHeight/2) + 'px';
      
      // Hide the original tile while dragging
      tile.style.opacity = '0.3';
      tile.classList.add('dragging');
      
      // Add haptic feedback if available
      if (navigator.vibrate) {
        navigator.vibrate(10);
      }
    }, 200); // 200ms delay for long press
  }
  
  function handleTouchMove(e) {
    var touch = e.touches[0];
    
    // If we haven't started dragging yet, check for movement
    if (!touchClone && touchStartTimer && touchStartPos) {
      var dx = Math.abs(touch.clientX - touchStartPos.x);
      var dy = Math.abs(touch.clientY - touchStartPos.y);
      
      // Cancel drag start if user moves finger significantly
      if (dx > 10 || dy > 10) {
        clearTimeout(touchStartTimer);
        touchStartTimer = null;
        touchStartPos = null;
        return;
      }
    }
    
    // Only prevent default if we're actually dragging
    if (!touchClone) return;
    e.preventDefault();
    
    // Update clone position
    touchClone.style.left = (touch.clientX - touchClone.offsetWidth/2) + 'px';
    touchClone.style.top = (touch.clientY - touchClone.offsetHeight/2) + 'px';
    
    // Find element under touch point (excluding the clone)
    touchClone.style.display = 'none';
    var elementBelow = document.elementFromPoint(touch.clientX, touch.clientY);
    touchClone.style.display = 'block';
    
    // Highlight drop zones
    var dropZones = document.querySelectorAll('.rank-slot, .team-drop-zone, #playerPool');
    dropZones.forEach(function(zone) {
      zone.classList.remove('drag-over');
    });
    
    if (elementBelow) {
      var dropZone = elementBelow.closest('.rank-slot, .team-drop-zone, #playerPool');
      if (dropZone) {
        dropZone.classList.add('drag-over');
      }
    }
  }
  
  function handleTouchEnd(e) {
    // Clear the timer if it's still running
    if (touchStartTimer) {
      clearTimeout(touchStartTimer);
      touchStartTimer = null;
    }
    touchStartPos = null;
    
    // If we haven't started dragging, restore opacity and return
    if (!touchClone || !draggedPlayer) {
      if (touchDraggedElement) {
        touchDraggedElement.style.opacity = '';
        touchDraggedElement.classList.remove('dragging');
        touchDraggedElement = null;
      }
      return;
    }
    
    e.preventDefault();
    
    var touch = e.changedTouches[0];
    
    // Find element under touch point
    touchClone.style.display = 'none';
    var elementBelow = document.elementFromPoint(touch.clientX, touch.clientY);
    touchClone.style.display = 'block';
    
    // Handle drop
    console.log('Touch end - checking for drop target');
    console.log('Element below:', elementBelow);
    console.log('Dragged player:', draggedPlayer);
    
    if (elementBelow) {
      var rankSlot = elementBelow.closest('.rank-slot');
      var teamZone = elementBelow.closest('.team-drop-zone');
      var pool = elementBelow.closest('#playerPool');
      
      console.log('Found rankSlot:', rankSlot);
      console.log('Found teamZone:', teamZone);
      console.log('Found pool:', pool);
      
      if (rankSlot) {
        console.log('Dropping on rank slot');
        handleRankDrop(rankSlot, draggedPlayer);
      } else if (teamZone) {
        console.log('Dropping on team zone');
        handleTeamDrop(teamZone, draggedPlayer);
      } else if (pool) {
        console.log('Dropping on pool');
        handlePoolDrop(draggedPlayer);
      } else {
        console.log('No valid drop target found');
      }
    } else {
      console.log('No element below touch point');
    }
    
    // Clean up - ensure clone is removed
    if (touchClone) {
      if (touchClone.parentNode) {
        touchClone.parentNode.removeChild(touchClone);
      }
      touchClone = null;
    }
    
    // Also clean up any other floating clones that might exist
    var floatingClones = document.querySelectorAll('.dragging');
    floatingClones.forEach(function(clone) {
      if (clone.style.position === 'fixed' && clone !== touchDraggedElement) {
        if (clone.parentNode) {
          clone.parentNode.removeChild(clone);
        }
      }
    });
    
    if (touchDraggedElement) {
      touchDraggedElement.classList.remove('dragging');
      touchDraggedElement.style.opacity = ''; // Restore original opacity
      touchDraggedElement.style.display = ''; // Ensure visibility is restored
      touchDraggedElement = null;
    }
    
    draggedPlayer = null;
    
    // Clear all highlights
    var dropZones = document.querySelectorAll('.rank-slot, .team-drop-zone, #playerPool');
    dropZones.forEach(function(zone) {
      zone.classList.remove('drag-over');
    });
    
    // Force re-render to clean up any visual artifacts
    setTimeout(function() {
      renderPlayerPool();
      renderRankingSlots();
    }, 10);
  }
  
  function updateRankingInput() {
    console.log('=== updateRankingInput called ===');
    console.log('currentRanking:', JSON.stringify(currentRanking));
    console.log('players:', players.map(function(p) { return {id: p.id, name: p.name, team: p.team}; }));
    
    var mode = parseInt(modeSel.value);
    console.log('Mode:', mode);
    
    var isMobile = 'ontouchstart' in window;
    console.log('Is Mobile:', isMobile);
    
    if (!isMobile) {
      // Let desktop handle it the original way
      console.log('Desktop mode - returning');
      return;
    }
    
    // Check if all positions are filled
    var allFilled = true;
    var filledCount = 0;
    for (var i = 1; i <= mode; i++) {
      if (!currentRanking[i]) {
        allFilled = false;
        console.log('Position ' + i + ' is empty');
      } else {
        filledCount++;
        console.log('Position ' + i + ' has player:', currentRanking[i]);
      }
    }
    
    console.log('Filled positions:', filledCount + '/' + mode);
    
    if (!allFilled) {
      console.log('Not all positions filled - returning');
      return;
    }
    
    // For mobile, match desktop's calculateFromRanking logic
    // First determine the winner based on who has rank 1
    var firstPlacePlayerId = currentRanking[1];
    var firstPlacePlayer = players.find(function(p) { return p.id === firstPlacePlayerId; });
    
    if (!firstPlacePlayer) {
      console.log('Error: Could not find first place player');
      return;
    }
    
    console.log('First place player:', firstPlacePlayer.name, 'Team:', firstPlacePlayer.team);
    
    // Set winner based on first place player's team
    var actualWinner = firstPlacePlayer.team === 1 ? 't1' : 't2';
    setWinner(actualWinner);
    console.log('Set winner to:', actualWinner);
    
    // Collect ranks for each team
    var team1Ranks = [];
    var team2Ranks = [];
    
    for (var rank = 1; rank <= mode; rank++) {
      var playerId = currentRanking[rank];
      if (playerId) {
        var player = players.find(function(p) { return p.id === playerId; });
        if (player) {
          if (player.team === 1) {
            team1Ranks.push(rank);
          } else {
            team2Ranks.push(rank);
          }
        }
      }
    }
    
    console.log('Team 1 ranks:', team1Ranks);
    console.log('Team 2 ranks:', team2Ranks);
    
    // Use the winning team's ranks for calculation
    var winnerRanks = actualWinner === 't1' ? team1Ranks : team2Ranks;
    winnerRanks.sort(function(a, b) { return a - b; });
    
    console.log('Winner ranks (sorted):', winnerRanks);
    
    // Set input to winning team's ranks only (not player names!)
    input.value = winnerRanks.join(' ');
    selected = winnerRanks.slice();
    console.log('Setting input.value to:', input.value);
    console.log('Setting selected to:', selected);
    
    // Calculate and check for auto-apply
    var result = calc();
    console.log('Called calc(), result:', result);
    
    // Auto-apply if enabled and calculation successful
    if (S.autoApply && result && result.ok) {
      console.log('Auto-applying result');
      applyResult();
    }
  }
  
  function handleRankDrop(slot, player) {
    console.log('=== handleRankDrop called ===');
    console.log('Slot:', slot);
    console.log('Player:', player);
    
    var rank = parseInt(slot.dataset.rank);
    console.log('Rank position:', rank);
    
    if (!rank) {
      console.log('No rank - returning');
      return;
    }
    
    // Clean up any floating clones immediately
    var existingClones = document.querySelectorAll('.dragging');
    existingClones.forEach(function(clone) {
      if (clone.style.position === 'fixed') {
        clone.remove();
      }
    });
    
    // Remove player from any existing rank
    for (var r in currentRanking) {
      if (currentRanking[r] === player.id) {
        console.log('Removing player from previous rank:', r);
        delete currentRanking[r];
      }
    }
    
    // Remove any existing player from this rank
    if (currentRanking[rank]) {
      console.log('Rank ' + rank + ' already has player:', currentRanking[rank]);
      var oldPlayer = players.find(function(p) { return p.id === currentRanking[rank]; });
      if (oldPlayer) {
        // Return old player to pool
        var poolTile = createRankingPlayerTile(oldPlayer);
        $('playerPool').appendChild(poolTile);
      }
    }
    
    // Add player to new rank
    console.log('Adding player', player.id, 'to rank', rank);
    currentRanking[rank] = player.id;
    console.log('Current ranking after update:', JSON.stringify(currentRanking));
    
    // Re-render everything to ensure clean state
    renderPlayerPool();
    renderRankingSlots();
    updateRankingInput();
    calc();
  }
  
  function handleTeamDrop(zone, player) {
    // Clean up any floating clones
    var existingClones = document.querySelectorAll('.dragging');
    existingClones.forEach(function(clone) {
      if (clone.style.position === 'fixed') {
        clone.remove();
      }
    });
    
    var team = zone.dataset.team;
    if (team === '1') {
      player.team = 'A';
    } else if (team === '2') {
      player.team = 'B';
    }
    setupDropZones();
    renderRankingArea();
  }
  
  function handlePoolDrop(player) {
    // Clean up any floating clones
    var existingClones = document.querySelectorAll('.dragging');
    existingClones.forEach(function(clone) {
      if (clone.style.position === 'fixed') {
        clone.remove();
      }
    });
    
    // Remove from ranking
    for (var r in currentRanking) {
      if (currentRanking[r] === player.id) {
        delete currentRanking[r];
      }
    }
    // Re-render everything to ensure clean state
    renderPlayerPool();
    renderRankingSlots();
    updateRankingInput();
    calc();
  }
  
  // Player System Functions
  function generatePlayers() {
    var num = parseInt(modeSel.value);
    
    // Try to load saved players first
    var savedPlayers = load('gd_players', []);
    if (savedPlayers.length === num) {
      players = savedPlayers;
      // Ensure saved players have proper IDs and teams
      players.forEach(function(player, index) {
        if (!player.id || typeof player.id === 'string') {
          player.id = index + 1;
        }
        if (!player.team) {
          player.team = index % 2 === 0 ? 'A' : 'B';
        }
      });
    } else {
      players = [];
      
      // Shuffle emojis
      var shuffledEmojis = animalEmojis.slice().sort(function() { return Math.random() - 0.5; });
      
      for (var i = 0; i < num; i++) {
        var player = {
          id: i + 1,  // Numeric ID matching player number
          name: 'ç©å®¶' + (i + 1),
          emoji: shuffledEmojis[i % shuffledEmojis.length],
          team: (i + 1)  // Store team as the player number for desktop compatibility
        };
        players.push(player);
      }
    }
    
    // Load saved player stats if available
    playerStats = load('gd_player_stats', {});
    
    renderPlayers();
    renderRankingArea();
  }
  
  function renderPlayers() {
    var unassigned = $('unassignedPlayers');
    var team1Zone = $('team1Zone');
    var team2Zone = $('team2Zone');
    
    // Clear zones
    unassigned.innerHTML = '';
    team1Zone.innerHTML = '<div class="label">æ‹–æ‹½ç©å®¶åˆ°è¿™é‡Œåˆ†é…é˜Ÿä¼</div>';
    team2Zone.innerHTML = '<div class="label">æ‹–æ‹½ç©å®¶åˆ°è¿™é‡Œåˆ†é…é˜Ÿä¼</div>';
    
    players.forEach(function(player) {
      var tile = createPlayerTile(player);
      
      if (player.team === 1) {
        team1Zone.appendChild(tile);
        tile.style.borderColor = S.t1.color;
      } else if (player.team === 2) {
        team2Zone.appendChild(tile);
        tile.style.borderColor = S.t2.color;
      } else {
        unassigned.appendChild(tile);
      }
    });
    
    updateTeamLabels();
  }
  
  function createPlayerTile(player) {
    var tile = document.createElement('div');
    tile.className = 'player-tile';
    tile.draggable = true;
    tile.dataset.playerId = player.id;
    
    var emoji = document.createElement('span');
    emoji.className = 'emoji';
    emoji.textContent = player.emoji;
    
    var nameInput = document.createElement('input');
    nameInput.type = 'text';
    nameInput.value = player.name;
    nameInput.onclick = function(e) { e.stopPropagation(); };
    // Update with debouncing for performance
    var updateTimer = null;
    var updateName = function() {
      player.name = this.value;
      save('gd_players', players);
      
      // Debounce the UI updates
      if (updateTimer) clearTimeout(updateTimer);
      updateTimer = setTimeout(function() {
        // Update ranking display if this player is ranked
        renderPlayerPool();
        renderRankingSlots();
        // Also update statistics display
        renderStatistics();
      }, 300);
    };
    nameInput.oninput = updateName;
    nameInput.onchange = function() {
      player.name = this.value;
      save('gd_players', players);
      // Immediate update on change (blur)
      if (updateTimer) clearTimeout(updateTimer);
      renderPlayerPool();
      renderRankingSlots();
      renderStatistics();
    };
    
    tile.appendChild(emoji);
    tile.appendChild(nameInput);
    
    // Drag events
    tile.ondragstart = function(e) {
      draggedPlayer = player;
      tile.classList.add('dragging');
      e.dataTransfer.effectAllowed = 'move';
    };
    
    tile.ondragend = function() {
      tile.classList.remove('dragging');
      draggedPlayer = null;
    };
    
    // Touch events for mobile
    tile.addEventListener('touchstart', function(e) {
      handleTouchStart(e, player);
    }, { passive: false });
    
    tile.addEventListener('touchmove', handleTouchMove, { passive: false });
    
    tile.addEventListener('touchend', handleTouchEnd, { passive: false });
    
    tile.addEventListener('touchcancel', handleTouchEnd, { passive: false });
    
    return tile;
  }
  
  function setupDropZones() {
    var zones = [
      { el: $('unassignedPlayers'), team: null },
      { el: $('team1Zone'), team: 1 },
      { el: $('team2Zone'), team: 2 }
    ];
    
    zones.forEach(function(zone) {
      zone.el.ondragover = function(e) {
        e.preventDefault();
        zone.el.classList.add('drag-over');
      };
      
      zone.el.ondragleave = function() {
        zone.el.classList.remove('drag-over');
      };
      
      zone.el.ondrop = function(e) {
        e.preventDefault();
        zone.el.classList.remove('drag-over');
        
        if (draggedPlayer) {
          draggedPlayer.team = zone.team;
          save('gd_players', players);
          renderPlayers();
          renderRankingArea();
        }
      };
    });
  }
  
  function shuffleTeams() {
    var num = parseInt(modeSel.value);
    var halfSize = num / 2;
    
    // Shuffle players
    var shuffled = players.slice().sort(function() { return Math.random() - 0.5; });
    
    // Assign to teams
    shuffled.forEach(function(player, i) {
      player.team = i < halfSize ? 1 : 2;
    });
    
    save('gd_players', players);
    renderPlayers();
    renderRankingArea();
  }
  
  function renderRankingArea() {
    var pool = $('playerPool');
    var area = $('rankingArea');
    var num = parseInt(modeSel.value);
    var allAssigned = players.every(function(p) { return p.team !== null; });
    
    if (!allAssigned) {
      pool.innerHTML = '<div class="small muted">è¯·å…ˆåˆ†é…æ‰€æœ‰ç©å®¶åˆ°é˜Ÿä¼</div>';
      area.innerHTML = '';
      return;
    }
    
    // Render player pool
    renderPlayerPool();
    
    // Render ranking slots
    area.innerHTML = '';
    
    for (var rank = 1; rank <= num; rank++) {
      var slot = document.createElement('div');
      slot.className = 'rank-slot';
      slot.dataset.rank = rank;
      
      var number = document.createElement('div');
      number.className = 'rank-number';
      number.textContent = 'ç¬¬' + rank + 'å';
      slot.appendChild(number);
      
      // Drop events for ranking
      slot.ondragover = function(e) {
        e.preventDefault();
        this.classList.add('drag-over');
      };
      
      slot.ondragleave = function() {
        this.classList.remove('drag-over');
      };
      
      slot.ondrop = (function(r) {
        return function(e) {
          e.preventDefault();
          this.classList.remove('drag-over');
          
          if (draggedPlayer) {
            // Check if another player was already in this rank
            var existingPlayerId = currentRanking[r];
            if (existingPlayerId && existingPlayerId !== draggedPlayer.id) {
              // Move existing player back to pool
              delete currentRanking[r];
            }
            
            // Remove from previous rank if any
            for (var oldRank in currentRanking) {
              if (currentRanking[oldRank] === draggedPlayer.id) {
                delete currentRanking[oldRank];
                break;
              }
            }
            
            // Add to new rank
            currentRanking[r] = draggedPlayer.id;
            renderPlayerPool();
            renderRankingSlots();
            // Force check auto calculate after updating ranking
            setTimeout(function() {
              checkAutoCalculate();
            }, 100);
          }
        };
      })(rank);
      
      area.appendChild(slot);
    }
  }
  
  function renderPlayerPool() {
    var pool = $('playerPool');
    pool.innerHTML = '';
    
    // Add drop zone for returning players to pool
    pool.ondragover = function(e) {
      e.preventDefault();
      pool.classList.add('drag-over');
    };
    
    pool.ondragleave = function() {
      pool.classList.remove('drag-over');
    };
    
    pool.ondrop = function(e) {
      e.preventDefault();
      pool.classList.remove('drag-over');
      
      if (draggedPlayer) {
        // Remove from ranking
        for (var rank in currentRanking) {
          if (currentRanking[rank] === draggedPlayer.id) {
            delete currentRanking[rank];
            break;
          }
        }
        renderPlayerPool();
        renderRankingSlots();
        checkAutoCalculate();
      }
    };
    
    // Add players not yet ranked
    players.forEach(function(player) {
      var isRanked = false;
      for (var rank in currentRanking) {
        if (currentRanking[rank] === player.id) {
          isRanked = true;
          break;
        }
      }
      
      if (!isRanked) {
        var tile = createRankingPlayerTile(player);
        pool.appendChild(tile);
      }
    });
    
    if (pool.children.length === 0) {
      pool.innerHTML = '<div class="small muted">æ‰€æœ‰ç©å®¶å·²æ’å</div>';
    }
  }
  
  function createRankingPlayerTile(player) {
    var tile = document.createElement('div');
    tile.className = 'ranking-player-tile';
    tile.draggable = true;
    tile.dataset.playerId = player.id;
    
    // Apply team color
    tile.style.borderColor = player.team === 1 ? S.t1.color : S.t2.color;
    
    var emoji = document.createElement('span');
    emoji.className = 'emoji';
    emoji.textContent = player.emoji;
    
    var name = document.createElement('span');
    name.className = 'name';
    name.textContent = player.name;
    
    tile.appendChild(emoji);
    tile.appendChild(name);
    
    // Drag events
    tile.ondragstart = function(e) {
      draggedPlayer = player;
      tile.classList.add('dragging');
      e.dataTransfer.effectAllowed = 'move';
    };
    
    tile.ondragend = function() {
      tile.classList.remove('dragging');
      draggedPlayer = null;
    };
    
    // Touch events for mobile
    tile.addEventListener('touchstart', function(e) {
      handleTouchStart(e, player);
    }, { passive: false });
    
    tile.addEventListener('touchmove', handleTouchMove, { passive: false });
    
    tile.addEventListener('touchend', handleTouchEnd, { passive: false });
    
    tile.addEventListener('touchcancel', handleTouchEnd, { passive: false });
    
    return tile;
  }
  
  function renderRankingSlots() {
    var area = $('rankingArea');
    var slots = area.querySelectorAll('.rank-slot');
    
    slots.forEach(function(slot) {
      var rank = parseInt(slot.dataset.rank);
      var playerId = currentRanking[rank];
      
      // Remove existing player tiles (keep rank number)
      var existingTiles = slot.querySelectorAll('.ranking-player-tile');
      existingTiles.forEach(function(t) { t.remove(); });
      
      if (playerId) {
        var player = players.find(function(p) { return p.id === playerId; });
        if (player) {
          var tile = createRankingPlayerTile(player);
          slot.appendChild(tile);
          slot.classList.add('filled');
        }
      } else {
        slot.classList.remove('filled');
      }
    });
  }
  
  function clearRanking() {
    currentRanking = {};
    renderPlayerPool();
    renderRankingSlots();
    checkAutoCalculate();
  }
  
  function randomizeRanking() {
    var num = parseInt(modeSel.value);
    
    // Check if all players are assigned to teams
    var allAssigned = players.every(function(p) { return p.team !== null; });
    if (!allAssigned) {
      alert('è¯·å…ˆåˆ†é…æ‰€æœ‰ç©å®¶åˆ°é˜Ÿä¼');
      return;
    }
    
    // Clear current ranking
    currentRanking = {};
    
    // Create a shuffled array of player IDs
    var playerIds = players.map(function(p) { return p.id; });
    
    // Fisher-Yates shuffle
    for (var i = playerIds.length - 1; i > 0; i--) {
      var j = Math.floor(Math.random() * (i + 1));
      var temp = playerIds[i];
      playerIds[i] = playerIds[j];
      playerIds[j] = temp;
    }
    
    // Assign shuffled players to ranking positions
    for (var rank = 1; rank <= num; rank++) {
      currentRanking[rank] = playerIds[rank - 1];
    }
    
    console.log('Randomized ranking:', currentRanking);
    
    // Update display
    renderPlayerPool();
    renderRankingSlots();
    
    // Auto calculate
    checkAutoCalculate();
  }
  
  
  function checkAutoCalculate() {
    var num = parseInt(modeSel.value);
    var rankedCount = 0;
    
    // Count how many players are actually ranked
    for (var i = 1; i <= num; i++) {
      if (currentRanking[i]) {
        rankedCount++;
      }
    }
    
    // Show current state
    console.log('checkAutoCalculate: ranked', rankedCount, 'of', num);
    
    var allRanked = rankedCount === num;
    
    if (allRanked) {
      console.log('All players ranked, calculating...');
      calculateFromRanking();
    } else {
      // Show progress
      headline.textContent = 'å·²æ’å ' + rankedCount + ' / ' + num + ' ä½ç©å®¶';
      explain.textContent = 'è¯·ç»§ç»­æ‹–æ‹½å‰©ä½™ç©å®¶åˆ°æ’åä½ç½®';
      if (winnerDisplay) winnerDisplay.textContent = 'â€”';
    }
  }
  
  function calculateFromRanking() {
    var num = parseInt(modeSel.value);
    
    // Count properly ranked players
    var rankedCount = 0;
    for (var i = 1; i <= num; i++) {
      if (currentRanking[i]) {
        rankedCount++;
      }
    }
    
    console.log('calculateFromRanking: ranked', rankedCount, 'of', num);
    
    if (rankedCount !== num) {
      // If not all players are ranked, clear results
      headline.textContent = 'ç­‰å¾…æ’åå®Œæˆ (' + rankedCount + '/' + num + ')';
      explain.textContent = 'è¯·å°†æ‰€æœ‰ç©å®¶æ‹–åˆ°æ’åä½ç½®';
      if (winnerDisplay) winnerDisplay.textContent = 'â€”';
      return;
    }
    
    // First, determine who won based on who has rank 1
    var firstPlacePlayerId = currentRanking[1];
    if (!firstPlacePlayerId) {
      headline.textContent = 'é”™è¯¯ï¼šæœªæ‰¾åˆ°ç¬¬1å';
      return;
    }
    
    var firstPlacePlayer = players.find(function(p) { return p.id === firstPlacePlayerId; });
    
    if (!firstPlacePlayer) {
      headline.textContent = 'é”™è¯¯ï¼šæœªæ‰¾åˆ°ç¬¬1åç©å®¶';
      return;
    }
    
    // Set winner based on who has first place
    var actualWinner = firstPlacePlayer.team === 1 ? 't1' : 't2';
    setWinner(actualWinner);
    
    var team1Ranks = [];
    var team2Ranks = [];
    
    for (var rank = 1; rank <= num; rank++) {
      var playerId = currentRanking[rank];
      if (playerId) {
        var player = players.find(function(p) { return p.id === playerId; });
        if (player) {
          if (player.team === 1) {
            team1Ranks.push(rank);
          } else {
            team2Ranks.push(rank);
          }
        }
      }
    }
    
    // Use the winning team's ranks for calculation
    var winnerRanks = actualWinner === 't1' ? team1Ranks : team2Ranks;
    winnerRanks.sort(function(a, b) { return a - b; });
    
    // Set the ranks input value
    input.value = winnerRanks.join(' ');
    selected = winnerRanks.slice();
    
    // Calculate and display results
    var result = calc();
    
    // Auto-apply if enabled and calculation successful
    if (S.autoApply && result.ok) {
      applyResult();
    }
  }
  
  function updatePlayerStats() {
    var num = parseInt(modeSel.value);
    var lastPlace = num; // 4, 6, or 8 depending on mode
    
    for (var rank = 1; rank <= num; rank++) {
      var playerId = currentRanking[rank];
      if (playerId) {
        var player = players.find(function(p) { return p.id === playerId; });
        if (player) {
          if (!playerStats[playerId]) {
            playerStats[playerId] = {
              games: 0,
              totalRank: 0,
              firstPlaceCount: 0,  // Count of 1st place finishes
              lastPlaceCount: 0,   // Count of last place finishes
              rankings: []
            };
          }
          
          var stats = playerStats[playerId];
          stats.games++;
          stats.totalRank += rank;
          stats.rankings.push(rank);
          
          // Count first and last places
          if (rank === 1) {
            stats.firstPlaceCount = (stats.firstPlaceCount || 0) + 1;
          }
          if (rank === lastPlace) {
            stats.lastPlaceCount = (stats.lastPlaceCount || 0) + 1;
          }
        }
      }
    }
    
    save('gd_player_stats', playerStats);
    renderStatistics();
  }
  
  function renderStatistics() {
    renderPlayerStatsTable();
    renderTeamMVPBurden();
  }
  
  function renderPlayerStatsTable() {
    var tbody = $('playerStatsBody');
    tbody.innerHTML = '';
    
    // Collect player data with stats
    var playerData = [];
    players.forEach(function(player) {
      var stats = playerStats[player.id];
      if (stats && stats.games > 0) {
        var avgRank = stats.totalRank / stats.games;
        playerData.push({
          player: player,
          stats: stats,
          avgRank: avgRank
        });
      }
    });
    
    if (playerData.length === 0) {
      tbody.innerHTML = '<tr><td colspan="6" class="muted small">æš‚æ— æ•°æ®</td></tr>';
      return;
    }
    
    // Sort by team first, then by average ranking (best to worst within each team)
    playerData.sort(function(a, b) {
      // First sort by team
      if (a.player.team !== b.player.team) {
        return (a.player.team || 999) - (b.player.team || 999); // Unassigned teams go last
      }
      // Then sort by average rank within team (lower is better)
      return a.avgRank - b.avgRank;
    });
    
    // Render sorted data
    playerData.forEach(function(data) {
      var player = data.player;
      var stats = data.stats;
      var tr = document.createElement('tr');
      var avgRankDisplay = data.avgRank.toFixed(2);
      var teamName = player.team === 1 ? S.t1.name : (player.team === 2 ? S.t2.name : 'æœªåˆ†é…');
      var teamColor = player.team === 1 ? S.t1.color : (player.team === 2 ? S.t2.color : '#666');
      
      // Add subtle team background
      if (player.team === 1 || player.team === 2) {
        tr.style.background = 'linear-gradient(90deg, ' + teamColor + '08, transparent)';
      }
      
      tr.innerHTML = '<td><span class="emoji">' + player.emoji + '</span>' + player.name + '</td>' +
                    '<td><span style="color:' + teamColor + ';font-weight:bold">' + teamName + '</span></td>' +
                    '<td>' + stats.games + '</td>' +
                    '<td><b>' + avgRankDisplay + '</b></td>' +
                    '<td>' + (stats.firstPlaceCount || 0) + '</td>' +
                    '<td>' + (stats.lastPlaceCount || 0) + '</td>';
      tbody.appendChild(tr);
    });
  }
  
  function renderTeamMVPBurden() {
    var team1Players = players.filter(function(p) { return p.team === 1; });
    var team2Players = players.filter(function(p) { return p.team === 2; });
    
    function findMVPAndBurden(teamPlayers) {
      var mvp = null, burden = null;
      var bestAvg = 999, worstAvg = 0;
      
      teamPlayers.forEach(function(player) {
        var stats = playerStats[player.id];
        if (stats && stats.games > 0) {
          var avg = stats.totalRank / stats.games;
          if (avg < bestAvg) {
            bestAvg = avg;
            mvp = player;
          }
          if (avg > worstAvg) {
            worstAvg = avg;
            burden = player;
          }
        }
      });
      
      return { mvp: mvp, burden: burden };
    }
    
    var team1Result = findMVPAndBurden(team1Players);
    var team2Result = findMVPAndBurden(team2Players);
    
    $('team1StatsTitle').textContent = S.t1.name;
    $('team2StatsTitle').textContent = S.t2.name;
    
    $('team1MVP').innerHTML = team1Result.mvp ? 
      '<span class="emoji">' + team1Result.mvp.emoji + '</span>' + team1Result.mvp.name : 'â€”';
    $('team1Burden').innerHTML = team1Result.burden ? 
      '<span class="emoji">' + team1Result.burden.emoji + '</span>' + team1Result.burden.name : 'â€”';
    
    $('team2MVP').innerHTML = team2Result.mvp ? 
      '<span class="emoji">' + team2Result.mvp.emoji + '</span>' + team2Result.mvp.name : 'â€”';
    $('team2Burden').innerHTML = team2Result.burden ? 
      '<span class="emoji">' + team2Result.burden.emoji + '</span>' + team2Result.burden.name : 'â€”';
  }
  
  function updateTeamLabels() {
    $('team1Label').textContent = S.t1.name;
    $('team2Label').textContent = S.t2.name;
    $('team1Label').style.color = S.t1.color;
    $('team2Label').style.color = S.t2.color;
  }

  // Utils
  function hexToRgb(hex){ var h=hex.replace('#',''); if(h.length===3) h=h[0]+h[0]+h[1]+h[1]+h[2]+h[2]; return {r:parseInt(h.substr(0,2),16),g:parseInt(h.substr(2,2),16),b:parseInt(h.substr(4,2),16)}; }
  function rgba(hex,a){ var c=hexToRgb(hex); return 'rgba('+c.r+','+c.g+','+c.b+','+a+')'; }
  function setWinner(w){ 
    winner=w; 
    if (winnerDisplay) {
      winnerDisplay.textContent = w === 't1' ? S.t1.name : S.t2.name;
      winnerDisplay.style.color = w === 't1' ? S.t1.color : S.t2.color;
    }
    refreshPreviewOnly(); 
  }
  function addRipple(ev,el,color){ var r=document.createElement('span'); var rect=el.getBoundingClientRect(), d=Math.max(rect.width,rect.height)*1.4; r.className='ripple'; r.style.width=r.style.height=d+'px'; r.style.left=(ev.clientX-rect.left-d/2)+'px'; r.style.top=(ev.clientY-rect.top-d/2)+'px'; r.style.background=rgba(color,.35); el.appendChild(r); setTimeout(function(){ if(r.parentNode) r.parentNode.removeChild(r); },650); }

  function applyTeamStyles(){ 
    t1NameChip.style.background=S.t1.color; 
    t2NameChip.style.background=S.t2.color; 
    t1NameChip.style.color=t2NameChip.style.color='#fff'; 
    t1NameChip.innerHTML='<b>'+S.t1.name+'</b>'; 
    t2NameChip.innerHTML='<b>'+S.t2.name+'</b>'; 
    hT1.innerText=S.t1.name; 
    hT2.innerText=S.t2.name; 
    autoNext.checked=!!S.autoNext;
    autoApply.checked=!!S.autoApply;
    strictA.checked=!!S.strictA; 
    // Update winner display if set
    if (winnerDisplay && winner) {
      winnerDisplay.textContent = winner === 't1' ? S.t1.name : S.t2.name;
      winnerDisplay.style.color = winner === 't1' ? S.t1.color : S.t2.color;
    }
  }
  applyTeamStyles();

  function updateRuleHint(){ var mode=modeSel.value; if(mode==='4'){ ruleHint.textContent='4äººï¼šå›ºå®šè¡¨ ('+S.c4['1,2']+','+S.c4['1,3']+','+S.c4['1,4']+')'; } else if(mode==='6'){ ruleHint.textContent='6äººï¼šåˆ†å·®â‰¥'+S.t6.g3+' å‡3ï¼›â‰¥'+S.t6.g2+' å‡2ï¼›â‰¥'+S.t6.g1+' å‡1'; } else { ruleHint.textContent='8äººï¼šåˆ†å·®â‰¥'+S.t8.g3+' å‡3ï¼›â‰¥'+S.t8.g2+' å‡2ï¼›â‰¥'+S.t8.g1+' å‡1'; } }
  updateRuleHint();

  function renderTeams(){ 
    t1Lvl.textContent=ST.t1.lvl; 
    t2Lvl.textContent=ST.t2.lvl; 
    t1A.textContent=ST.t1.aFail||0; 
    t2A.textContent=ST.t2.aFail||0; 
    t1AState.textContent=(ST.t1.lvl==='A')?('A'+(ST.t1.aFail||0)+'/3'):'â€”'; 
    t2AState.textContent=(ST.t2.lvl==='A')?('A'+(ST.t2.aFail||0)+'/3'):'â€”'; 
    
    // Show which team's level we're playing at
    var roundTeamName = '';
    if (String(ST.roundLevel) === String(ST.t1.lvl) && String(ST.roundLevel) !== String(ST.t2.lvl)) {
      roundTeamName = ' (' + S.t1.name + ')';
    } else if (String(ST.roundLevel) === String(ST.t2.lvl) && String(ST.roundLevel) !== String(ST.t1.lvl)) {
      roundTeamName = ' (' + S.t2.name + ')';
    }
    curRoundLvl.textContent = ST.roundLevel + roundTeamName;
    console.log('renderTeams: displaying roundLevel =', ST.roundLevel, 'with team name =', roundTeamName);
    
    // Show next round preview with team name
    var nextRound = ST.nextRoundBase || ST.roundLevel || '-';
    var nextTeamName = '';
    if (ST.nextRoundBase) {
      // There's a pending next round, figure out which team it would be
      if (ST.nextRoundBase === ST.t1.lvl && ST.nextRoundBase !== ST.t2.lvl) {
        nextTeamName = ' (' + S.t1.name + ')';
      } else if (ST.nextRoundBase === ST.t2.lvl && ST.nextRoundBase !== ST.t1.lvl) {
        nextTeamName = ' (' + S.t2.name + ')';
      }
    }
    nextRoundPreview.textContent = nextRound + nextTeamName;
  }
  renderTeams();

  // Rules saving
  function collectAndSaveRules(){ S.c4={'1,2':+$('c4_12').value||0,'1,3':+$('c4_13').value||0,'1,4':+$('c4_14').value||0}; S.t6={g3:+$('t6_3').value||7,g2:+$('t6_2').value||4,g1:+$('t6_1').value||1}; S.p6={1:+$('p6_1').value||0,2:+$('p6_2').value||0,3:+$('p6_3').value||0,4:+$('p6_4').value||0,5:+$('p6_5').value||0,6:+$('p6_6').value||0}; S.t8={g3:+$('t8_3').value||11,g2:+$('t8_2').value||6,g1:+$('t8_1').value||1}; S.p8={1:+$('p8_1').value||0,2:+$('p8_2').value||0,3:+$('p8_3').value||0,4:+$('p8_4').value||0,5:+$('p8_5').value||0,6:+$('p8_6').value||0,7:+$('p8_7').value||0,8:+$('p8_8').value||0}; save(KEY_S,S); updateRuleHint(); refreshPreviewOnly(); }
  on($('save4'),'click',collectAndSaveRules); on($('save6'),'click',collectAndSaveRules); on($('save8'),'click',collectAndSaveRules);
  must1.checked=!!S.must1; on(must1,'change',function(){ S.must1=!!must1.checked; save(KEY_S,S); refreshPreviewOnly(); });
  on(autoNext,'change',function(){ S.autoNext=!!autoNext.checked; save(KEY_S,S); });
  on(autoApply,'change',function(){ S.autoApply=!!autoApply.checked; save(KEY_S,S); });
  on(strictA,'change',function(){ S.strictA=!!strictA.checked; save(KEY_S,S); });

  // Helpers
  function parseRanks(text, need){ if(!text) return {ok:false,msg:'è¯·è¾“å…¥åæ¬¡'}; var t=String(text).trim(), maxn=(need===2?4:(need===3?6:8)), re=new RegExp('^[0-9]{'+need+'}$'); if(re.test(t)){ var arr=t.split(''), nums=[], i; for(i=0;i<arr.length;i++) nums.push(parseInt(arr[i],10)); var seen={}, j; for(j=0;j<nums.length;j++){ if(nums[j]<1||nums[j]>maxn) return {ok:false,msg:'åæ¬¡è¶…å‡ºèŒƒå›´'}; if(seen[nums[j]]) return {ok:false,msg:'åæ¬¡ä¸èƒ½é‡å¤'}; seen[nums[j]]=1; } nums.sort(function(a,b){return a-b;}); return {ok:true,ranks:nums}; } var parts=t.replace(/[^0-9]+/g,' ').trim().split(/\s+/); if(parts.length!==need) return {ok:false,msg:'éœ€è¦ '+need+' ä¸ªåæ¬¡'}; var nums2=[], k; for(k=0;k<parts.length;k++){ var n=parseInt(parts[k],10); if(!(n>=1&&n<=maxn)) return {ok:false,msg:'åæ¬¡å¿…é¡»åœ¨ 1~'+maxn}; nums2.push(n); } var seen2={}, m; for(m=0;m<nums2.length;m++){ if(seen2[nums2[m]]) return {ok:false,msg:'åæ¬¡ä¸èƒ½é‡å¤'}; seen2[nums2[m]]=1; } nums2.sort(function(a,b){return a-b;}); return {ok:true,ranks:nums2}; }
  function sum(a){var s=0,i;for(i=0;i<a.length;i++)s+=a[i];return s;}
  function scoreSum(r,map){var s=0,i;for(i=0;i<r.length;i++)s+=(map[r[i]]||0);return s;}
  function tier(diff,t){if(diff>=t.g3)return 3;if(diff>=t.g2)return 2;if(diff>=t.g1)return 1;return 0;}
  function nextLevel(curr,inc){var L=['2','3','4','5','6','7','8','9','10','J','Q','K','A'];var i=Math.max(0,L.indexOf(curr));return L[Math.min(L.length-1,i+inc)];}

  function calc(){
    var mode=modeSel.value, need=(mode==='4'?2:(mode==='6'?3:4));
    
    // Check if we have valid ranking input
    if (!input.value) {
      headline.textContent='ç­‰å¾…æ’åå®Œæˆ';
      explain.textContent='è¯·å°†æ‰€æœ‰ç©å®¶æ‹–åˆ°æ’åä½ç½®';
      refreshPreviewOnly();
      return {ok:false};
    }
    
    var pr=parseRanks(input.value, need);
    if(!pr.ok){ headline.textContent='è¾“å…¥æœ‰è¯¯'; explain.textContent=pr.msg; refreshPreviewOnly(); return {ok:false}; }
    var r=pr.ranks, up=0, ours=null, opp=null, diff=null;
    if(mode==='4'){ up=S.c4[r[0]+','+r[1]]||0; }
    else if(mode==='6'){ ours=scoreSum(r,S.p6); opp=sum([S.p6[1],S.p6[2],S.p6[3],S.p6[4],S.p6[5],S.p6[6]])-ours; diff=ours-opp; up=(S.must1 && r.indexOf(1)===-1)?0:tier(diff,S.t6); }
    else{ 
      // Special case: if team gets 1,2,3,4 (complete sweep), upgrade 4 levels
      if(r.length === 4 && r[0] === 1 && r[1] === 2 && r[2] === 3 && r[3] === 4) {
        up = 4;
      } else {
        ours=scoreSum(r,S.p8); opp=sum([S.p8[1],S.p8[2],S.p8[3],S.p8[4],S.p8[5],S.p8[6],S.p8[7],S.p8[8]])-ours; diff=ours-opp; up=(S.must1 && r.indexOf(1)===-1)?0:tier(diff,S.t8);
      }
    }
    // Add team name to upgrade label
    var winnerName = winner === 't1' ? S.t1.name : S.t2.name;
    var label=(up>0?(winnerName+' å‡ '+up+' çº§'):'ä¸å‡çº§');
    var base=ST.roundLevel;
    // Calculate what the next round would be if we apply this result
    var winnerCurrentLevel = (winner==='t1')?ST.t1.lvl:ST.t2.lvl;
    var winnerNewLevel = nextLevel(winnerCurrentLevel, up);
    var preview = ST.nextRoundBase || winnerNewLevel;
    // Get team names for display
    var winnerName = winner === 't1' ? S.t1.name : S.t2.name;
    var loserName = winner === 't1' ? S.t2.name : S.t1.name;
    var currentRoundTeam = base === ST.t1.lvl ? S.t1.name : (base === ST.t2.lvl ? S.t2.name : '');
    headline.textContent=(mode+'äººï¼š'+ '('+r.join(',')+')'+' â†’ '+label+'ï½œæœ¬å±€ '+base+(currentRoundTeam?' ('+currentRoundTeam+')':'')+' â†’ ä¸‹å±€ '+preview+' ('+winnerName+')');
    explain.textContent=(mode==='4'?'4äººè¡¨ï¼š(1,2)='+S.c4['1,2']+'ï¼›(1,3)='+S.c4['1,3']+'ï¼›(1,4)='+S.c4['1,4'] : 'åˆ†å·®ä¸èµ„æ ¼è§„åˆ™å·²è®¡ç®—');
    refreshPreviewOnly();
    return {ok:true,mode:mode,ranks:r,up:up,base:base,preview:winnerNewLevel};
  }

  function refreshPreviewOnly(){ 
    // If there's a pending next round, show it. Otherwise show current winner's level
    if (ST.nextRoundBase) {
      nextRoundPreview.textContent = ST.nextRoundBase;
    } else {
      // In auto-next mode or no pending round, preview is same as current round
      nextRoundPreview.textContent = ST.roundLevel || '-';
    }
  }


  // History
  var histBody=$('histBody'), exportTip=$('exportTip');
  function renderHistory(){ 
    histBody.innerHTML=''; 
    for(var i=0;i<ST.hist.length;i++){ 
      (function(idx){ 
        var h=ST.hist[idx]; 
        var tr=document.createElement('tr'); 
        tr.className='tinted'; 
        // Add color coding based on winning team
        var winColor = h.winKey === 't1' ? S.t1.color : S.t2.color;
        tr.style.background = 'linear-gradient(90deg, ' + winColor + '10, transparent)';
        
        // Add team name to upgrade display
        var upgradeText = h.up ? (h.win + ' å‡' + h.up + 'çº§') : 'ä¸å‡çº§';
        
        // Build player ranking display if available
        var rankingDisplay = '';
        if (h.playerRankings) {
          var rankingParts = [];
          for (var i = 1; i <= parseInt(h.mode); i++) {
            if (h.playerRankings[i]) {
              var p = h.playerRankings[i];
              var teamColor = p.team === 1 ? S.t1.color : S.t2.color;
              rankingParts.push('<span style="color:' + teamColor + '">' + p.emoji + p.name + '</span>');
            }
          }
          if (rankingParts.length > 0) {
            rankingDisplay = rankingParts.join(' ');
          }
        }
        
        // Keep the original combo display
        var comboDisplay = h.combo || '';
        
        tr.innerHTML='<td>'+(idx+1)+'</td><td>'+h.ts+'</td><td>'+h.mode+'</td><td>'+comboDisplay+'</td><td>'+rankingDisplay+'</td><td>'+upgradeText+'</td><td style="color:'+winColor+';font-weight:bold">'+h.win+'</td><td>'+h.t1+'</td><td>'+h.t2+'</td><td>'+h.round+'</td><td>'+h.aNote+'</td>'; 
        var td=document.createElement('td'); 
        var b=document.createElement('button'); 
        b.textContent='å›æ»šè‡³æ­¤å‰'; 
        b.onclick=function(){ rollbackTo(idx); }; 
        td.appendChild(b); 
        tr.appendChild(td); 
        histBody.appendChild(tr); 
      })(i); 
    } 
  }

  // Apply & advance
  function applyResult(){ var r=calc(); if(!r.ok){ applyTip.textContent='è¯·å…ˆè®¡ç®—'; return; } var win=winner, lose=(win==='t1'?'t2':'t1'); var thisRound = ST.roundLevel;
    // Snapshot
    var snap={prevT1Lvl:ST.t1.lvl,prevT1A:ST.t1.aFail||0,prevT2Lvl:ST.t2.lvl,prevT2A:ST.t2.aFail||0,prevRound:ST.roundLevel};
    // å‡çº§
    var winNew=nextLevel(ST[win].lvl, r.up), loseNew=ST[lose].lvl;
    var nextBaseByRule = winNew; // å…³é”®ï¼šä¸‹å±€ = èƒœæ–¹å‡çº§åçš„çº§ç‰Œ
    // A è§„åˆ™
    var aNote='', finalWin=false, aTeam=null;
    var lastR=(r.mode==='4'?4:(r.mode==='6'?6:8)), winnerHasLast=(r.ranks.indexOf(lastR)>=0);
    if(ST.t1.lvl==='A' && ST.t2.lvl==='A') aTeam=win; else if(ST.t1.lvl==='A') aTeam='t1'; else if(ST.t2.lvl==='A') aTeam='t2';
    if(aTeam){
      if(aTeam===win){
        if(winnerHasLast){ // èƒœæ–¹å¸¦æœ«æ¸¸ -> ä¸é€šå…³ï¼Œå¤±è´¥+1
          ST[aTeam].aFail=(ST[aTeam].aFail||0)+1; aNote=((aTeam==='t1'?S.t1.name:S.t2.name))+' Açº§å¤±è´¥ï¼ˆèƒœæ–¹å«æœ«æ¸¸ï¼‰â†’ A'+ST[aTeam].aFail;
          if(ST[aTeam].aFail>=3){ 
            winNew='2'; // Reset winner to level 2
            ST[aTeam].aFail=0; 
            aNote+='ï½œç´¯è®¡3æ¬¡å¤±è´¥ï¼Œä»…è¯¥é˜Ÿé‡ç½®åˆ°2'; 
          } else {
            winNew=ST[win].lvl; // æœ¬å±€ä¸å‡çº§
          }
        }else{
          // Check strict mode - in strict mode, must win at YOUR OWN A level
          if(S.strictA && ST.roundLevel !== 'A'){
            // In strict mode, winning at other team's level doesn't count as é€šå…³
            aNote=((aTeam==='t1'?S.t1.name:S.t2.name))+' Açº§èƒœåˆ©ï¼ˆä½†æœ¬å±€çº§ç‰Œä¸º'+ST.roundLevel+'ï¼Œéœ€åœ¨è‡ªå·±çš„Açº§è·èƒœæ‰èƒ½é€šå…³ï¼‰';
            // Still no upgrade, but no failure count increase
            winNew=ST[win].lvl;
          } else {
            // Either lenient mode, or strict mode and playing at A level
            finalWin=true; 
            aNote=((aTeam==='t1'?S.t1.name:S.t2.name))+' Açº§é€šå…³ï¼ˆèƒœæ–¹æ— æœ«æ¸¸'+(S.strictA?'ï¼Œåœ¨è‡ªå·±çš„Açº§':'')+')';
          }
        }
      }else{
        ST[aTeam].aFail=(ST[aTeam].aFail||0)+1; aNote=((aTeam==='t1'?S.t1.name:S.t2.name))+' Açº§å¤±è´¥ï¼ˆæœªå–èƒœï¼‰â†’ A'+ST[aTeam].aFail;
        if(ST[aTeam].aFail>=3){ 
          // Reset the losing A-team to level 2
          if(aTeam === win) {
            winNew = '2';
          } else {
            loseNew = '2';
          }
          ST[aTeam].aFail=0; 
          aNote+='ï½œç´¯è®¡3æ¬¡å¤±è´¥ï¼Œä»…è¯¥é˜Ÿé‡ç½®åˆ°2'; 
        }
      }
    }
    // åº”ç”¨å‡çº§è‡³é˜Ÿä¼
    ST[win].lvl=winNew; ST[lose].lvl=loseNew;
    // å†³å®šå¹¶ä¿å­˜"ä¸‹å±€çº§ç‰Œ"
    if(S.autoNext || finalWin){ 
      ST.roundLevel = String(nextBaseByRule); // Move to next round (winner's new level)
      ST.nextRoundBase=null; 
      console.log('Auto advancing: roundLevel set to', ST.roundLevel, 'from', thisRound);
    }
    else { 
      ST.roundLevel = String(thisRound); // Stay at current round
      ST.nextRoundBase = String(nextBaseByRule); // But preview shows what next round would be
      console.log('Manual mode: roundLevel stays at', ST.roundLevel, 'next would be', ST.nextRoundBase);
    }
    // Build player ranking details for history
    var playerRankings = {};
    for (var rank in currentRanking) {
      var playerId = currentRanking[rank];
      var player = players.find(function(p) { return p.id === playerId; });
      if (player) {
        playerRankings[rank] = {
          id: player.id,
          name: player.name,
          emoji: player.emoji,
          team: player.team
        };
      }
    }
    
    // å†™å†å²
    var row={ts:now(),mode:r.mode,combo:'('+r.ranks.join(',')+')',up:r.up,win:(win==='t1'?S.t1.name:S.t2.name),t1:ST.t1.lvl,t2:ST.t2.lvl,round:thisRound,aNote:aNote,winKey:win,prevT1Lvl:snap.prevT1Lvl,prevT1A:snap.prevT1A,prevT2Lvl:snap.prevT2Lvl,prevT2A:snap.prevT2A,prevRound:snap.prevRound,playerRankings:playerRankings};
    ST.hist.push(row); save(KEY_ST,ST);
    // Update player stats
    updatePlayerStats();
    // Clear ranking for next round
    currentRanking = {};
    input.value = ''; // Clear the input as well
    renderTeams(); renderHistory(); calc();
    renderRankingArea();
    applyTip.textContent = finalWin ? ('ğŸ‰ '+row.win+' Açº§é€šå…³ï¼') : (S.autoNext ? 'å·²åº”ç”¨ï¼Œå·²è¿›å…¥ä¸‹ä¸€å±€ï¼ˆæœ¬å±€â†’ä¸‹å±€ï¼š'+thisRound+'â†’'+nextBaseByRule+'ï¼‰ã€‚' : 'å·²åº”ç”¨ã€‚ä¸‹å±€çº§ç‰Œï¼š'+nextBaseByRule+'ã€‚');
    
    // Show victory modal if A-level was won
    if (finalWin) {
      showVictoryModal(row.win);
    }
    
    // Clear ranking for next round if auto-apply is enabled
    if (S.autoApply) {
      clearRanking();
    }
  }

  function doAdvance(){ if(ST.nextRoundBase){ ST.roundLevel = ST.nextRoundBase; ST.nextRoundBase=null; save(KEY_ST,ST); renderTeams(); calc(); applyTip.textContent='å·²è¿›å…¥ä¸‹ä¸€å±€'; } else { applyTip.textContent='æ²¡æœ‰å¾…è¿›å…¥çš„ä¸‹ä¸€å±€ï¼ˆæˆ–å·²è‡ªåŠ¨è¿›å…¥ï¼‰ã€‚'; } }

  // Rollback/undo/reset
  function rollbackTo(index){ if(index<0||index>=ST.hist.length) return; var h=ST.hist[index]; if(!confirm('å›æ»šåˆ°ç¬¬ '+(index+1)+' å±€ä¹‹å‰ï¼Ÿ')) return; ST.t1.lvl=h.prevT1Lvl; ST.t1.aFail=h.prevT1A||0; ST.t2.lvl=h.prevT2Lvl; ST.t2.aFail=h.prevT2A||0; ST.roundLevel=h.prevRound||'2'; ST.nextRoundBase=null; ST.hist=ST.hist.slice(0,index); save(KEY_ST,ST); renderTeams(); renderHistory(); calc(); applyTip.textContent='å·²å›æ»šã€‚'; }
  function undoLast(){ if(!ST.hist.length){ alert('æ²¡æœ‰å¯æ’¤é”€çš„è®°å½•'); return; } rollbackTo(ST.hist.length-1); }
  function resetAll(){ 
    if(!confirm('é‡ç½®æ•´åœºï¼Ÿ')) return; 
    // Reset state to initial values
    ST={t1:{lvl:'2',aFail:0},t2:{lvl:'2',aFail:0},hist:[],roundLevel:'2',nextRoundBase:null}; 
    save(KEY_ST,ST); 
    
    // Clear player-related state
    selected=[]; 
    input.value=''; 
    playerStats = {}; 
    save('gd_player_stats', {}); 
    currentRanking = {};
    
    // Re-render everything
    renderTeams(); 
    renderHistory(); 
    calc(); 
    renderStatistics(); 
    renderRankingArea();
    generatePlayers(); // Regenerate players to ensure clean state
    
    applyTip.textContent='å·²é‡ç½®æ•´åœºæ¯”èµ›';
    
    // Close victory modal if it's open
    closeVictoryModal();
  }

  // Victory Modal
  function showVictoryModal(teamName) {
    var modal = $('victoryModal');
    var modalContent = modal.querySelector('div');
    var teamNameEl = $('victoryTeamName');
    
    // Determine which team won and get their color
    var winningTeamColor = '';
    if (teamName === S.t1.name) {
      winningTeamColor = S.t1.color;
    } else if (teamName === S.t2.name) {
      winningTeamColor = S.t2.color;
    }
    
    // Update modal content
    teamNameEl.textContent = teamName;
    teamNameEl.style.color = winningTeamColor;
    
    // Update modal border color
    modalContent.style.borderColor = winningTeamColor;
    modalContent.style.boxShadow = '0 0 30px ' + winningTeamColor + '40';
    
    modal.style.display = 'flex';
  }
  
  function closeVictoryModal() {
    var modal = $('victoryModal');
    modal.style.display = 'none';
  }
  
  // Make functions globally accessible
  window.closeVictoryModal = closeVictoryModal;
  window.exportTXT = exportTXT;
  window.exportCSV = exportCSV;
  window.exportLongPNG = exportLongPNG;
  window.resetAll = resetAll;
  
  // Exports
  var exportTip=$('exportTip');
  function exportTXT(){ 
    var lines=['æ¼è›‹æˆ˜ç»©å¯¼å‡ºï¼ˆv8.0ï¼‰','================',
      'å½“å‰æœ¬å±€çº§ç‰Œï¼š'+ST.roundLevel,
      'ä¸‹å±€é¢„è§ˆï¼š'+(ST.nextRoundBase||'â€”'),
      (S.t1.name||'é˜Ÿ1')+'çº§ç‰Œï¼š'+ST.t1.lvl+'ï½œA'+(ST.t1.aFail||0)+'/3',
      (S.t2.name||'é˜Ÿ2')+'çº§ç‰Œï¼š'+ST.t2.lvl+'ï½œA'+(ST.t2.aFail||0)+'/3',
      'Açº§è§„åˆ™ï¼š'+(S.strictA?'ä¸¥æ ¼æ¨¡å¼':'å®½æ¾æ¨¡å¼'),
      '',
      '#  æ—¶é—´ | äººæ•° | èƒœæ–¹ç»„åˆ | ç©å®¶æ’å | å‡çº§æƒ…å†µ | èƒœé˜Ÿ | '+S.t1.name+'çº§ | '+S.t2.name+'çº§ | æœ¬å±€çº§ | Aè¯´æ˜'
    ]; 
    for(var i=0;i<ST.hist.length;i++){ 
      var h=ST.hist[i]; 
      // Build player ranking string
      var playerRankStr = '';
      if(h.playerRankings){
        var rankParts = [];
        for(var r=1; r<=parseInt(h.mode); r++){
          if(h.playerRankings[r]){
            var p = h.playerRankings[r];
            rankParts.push(p.emoji+p.name);
          }
        }
        playerRankStr = rankParts.join(' ');
      }
      var upgradeStr = h.up ? (h.win + ' å‡' + h.up + 'çº§') : 'ä¸å‡çº§';
      lines.push([i+1,h.ts,h.mode,h.combo,playerRankStr,upgradeStr,h.win,h.t1,h.t2,h.round,h.aNote].join(' | ')); 
    } 
    var blob=new Blob([lines.join('\n')],{type:'text/plain;charset=utf-8'}); 
    var a=document.createElement('a'); 
    a.href=URL.createObjectURL(blob); 
    a.download='æ¼è›‹æˆ˜ç»©_v8.txt'; 
    a.click(); 
    exportTip.textContent='å·²å¯¼å‡º TXT'; 
    setTimeout(function(){exportTip.textContent='';},1200); 
  }
  function csvEscape(v){ var s=String(v).replace(/"/g,'""'); if(s.search(/[",\n]/)>=0) s='"'+s+'"'; return s; }
  function exportCSV(){ 
    var rows=[['#','æ—¶é—´','äººæ•°','èƒœæ–¹ç»„åˆ','ç©å®¶æ’å','å‡çº§æƒ…å†µ','èƒœé˜Ÿ',S.t1.name+'çº§',S.t2.name+'çº§','æœ¬å±€çº§','Aè¯´æ˜','Açº§è§„åˆ™']]; 
    for(var i=0;i<ST.hist.length;i++){ 
      var h=ST.hist[i]; 
      // Build player ranking string
      var playerRankStr = '';
      if(h.playerRankings){
        var rankParts = [];
        for(var r=1; r<=parseInt(h.mode); r++){
          if(h.playerRankings[r]){
            var p = h.playerRankings[r];
            rankParts.push(p.emoji+p.name);
          }
        }
        playerRankStr = rankParts.join(' ');
      }
      var upgradeStr = h.up ? (h.win + ' å‡' + h.up + 'çº§') : 'ä¸å‡çº§';
      rows.push([i+1,h.ts,h.mode,h.combo,playerRankStr,upgradeStr,h.win,h.t1,h.t2,h.round,h.aNote,S.strictA?'ä¸¥æ ¼':'å®½æ¾']); 
    } 
    var lines=rows.map(function(r){ return r.map(csvEscape).join(','); }).join('\n'); 
    var blob=new Blob([lines],{type:'text/csv;charset=utf-8'}); 
    var a=document.createElement('a'); 
    a.href=URL.createObjectURL(blob); 
    a.download='æ¼è›‹æˆ˜ç»©_v8.csv'; 
    a.click(); 
    exportTip.textContent='å·²å¯¼å‡º CSV'; 
    setTimeout(function(){exportTip.textContent='';},1200); 
  }
  function exportLongPNG(){ 
    var W=2200, headH=220, rowH=40, n=ST.hist.length, H=headH+(n+1)*rowH+80; 
    longCnv.width=W; longCnv.height=H; 
    lctx.fillStyle='#0b0b0c'; lctx.fillRect(0,0,W,H); 
    lctx.fillStyle='#f5f6f8'; 
    lctx.font='bold 48px Arial'; 
    lctx.fillText('æ¼è›‹æˆ˜ç»©æ€»è§ˆ v8.0',40,70); 
    lctx.font='20px Arial'; 
    lctx.fillStyle='#b4b8bf'; 
    lctx.fillText('å½“å‰æœ¬å±€çº§ç‰Œï¼š'+ST.roundLevel+'ï½œä¸‹å±€é¢„è§ˆï¼š'+(ST.nextRoundBase||'â€”')+'ï½œAçº§è§„åˆ™ï¼š'+(S.strictA?'ä¸¥æ ¼æ¨¡å¼':'å®½æ¾æ¨¡å¼'),40,110); 
    lctx.fillText('é˜Ÿä¼ï¼š'+S.t1.name+'ï¼ˆ'+ST.t1.lvl+'ï¼ŒA'+(ST.t1.aFail||0)+'/3ï¼‰ | '+S.t2.name+'ï¼ˆ'+ST.t2.lvl+'ï¼ŒA'+(ST.t2.aFail||0)+'/3ï¼‰',40,140); 
    lctx.fillText('ç”Ÿæˆæ—¶é—´ï¼š'+now(),40,170); 
    
    var cols=['#','æ—¶é—´','äººæ•°','èƒœæ–¹ç»„åˆ','ç©å®¶æ’å','å‡çº§','èƒœé˜Ÿ',S.t1.name+'çº§',S.t2.name+'çº§','æœ¬å±€çº§','Aè¯´æ˜']; 
    var xs=[40,80,240,300,440,700,800,900,1000,1100,1200]; 
    lctx.font='bold 20px Arial'; 
    lctx.fillStyle='#e6b800'; 
    for(var c=0;c<cols.length;c++) lctx.fillText(cols[c], xs[c], headH); 
    
    lctx.font='14px Arial'; 
    for(var i=0;i<n;i++){ 
      var h=ST.hist[i], y=headH+(i+1)*rowH; 
      
      // Add row background color based on winning team
      var winColor = h.winKey === 't1' ? S.t1.color : S.t2.color;
      lctx.fillStyle = winColor + '10'; // Very light background
      lctx.fillRect(0, y - rowH + 10, W, rowH);
      
      // Build player ranking string with emoji and names
      var playerRankStr = '';
      if(h.playerRankings) {
        var rankParts = [];
        for(var r=1; r<=8; r++) {
          if(h.playerRankings[r]) {
            var p = h.playerRankings[r];
            rankParts.push(p.emoji + p.name);
          }
        }
        playerRankStr = rankParts.join(' ');
      }
      
      var upgradeStr = h.up ? (h.win + ' å‡' + h.up) : 'ä¸å‡';
      var vals=[i+1,h.ts.substring(0,16),h.mode,h.combo,playerRankStr,upgradeStr,h.win,h.t1,h.t2,h.round,h.aNote||'']; 
      
      // Set text color
      lctx.fillStyle='#f5f6f8';
      
      for(var j=0;j<vals.length;j++) {
        var text = String(vals[j]);
        // Wrap long A notes
        if(j === 10 && text.length > 50) {
          var maxWidth = 800;
          var words = text.split(' ');
          var line = '';
          var lineY = y;
          for(var w = 0; w < words.length; w++) {
            var testLine = line + words[w] + ' ';
            var metrics = lctx.measureText(testLine);
            if (metrics.width > maxWidth && w > 0) {
              lctx.fillText(line, xs[j], lineY);
              line = words[w] + ' ';
              lineY += 15;
            } else {
              line = testLine;
            }
          }
          lctx.fillText(line, xs[j], lineY);
        } else {
          lctx.fillText(text, xs[j], y);
        }
      }
    } 
    var a=document.createElement('a'); 
    a.href=longCnv.toDataURL('image/png'); 
    a.download='æ¼è›‹æˆ˜ç»©_v8.png'; 
    a.click(); 
  }

  // Events
  on(modeSel,'change', function(){ selected=[]; input.value=''; updateRuleHint(); calc(); generatePlayers(); });
  on(applyBtn,'click', applyResult); on(advanceBtn,'click', doAdvance);
  on($('undo'),'click', undoLast);
  on($('exportTxt'),'click', exportTXT); on($('exportCsv'),'click', exportCSV); on($('exportLongPng'),'click', exportLongPNG);
  on($('resetMatch'),'click', resetAll);
  
  // Player system events
  on($('generatePlayers'),'click', generatePlayers);
  on($('shuffleTeams'),'click', shuffleTeams);
  on($('clearRanking'),'click', clearRanking);
  on($('randomRanking'),'click', randomizeRanking);
  on($('manualCalc'),'click', function() {
    // Force rebuild currentRanking from what's actually in the slots
    var area = $('rankingArea');
    var slots = area.querySelectorAll('.rank-slot');
    var newRanking = {};
    
    slots.forEach(function(slot) {
      var rank = parseInt(slot.dataset.rank);
      var playerTile = slot.querySelector('.ranking-player-tile');
      if (playerTile) {
        var playerId = playerTile.dataset.playerId;
        if (playerId) {
          newRanking[rank] = playerId;
        }
      }
    });
    
    console.log('Rebuilt ranking from UI:', newRanking);
    currentRanking = newRanking;
    
    // Now calculate
    calculateFromRanking();
    
    // Also trigger apply if calculation was successful
    var r = calc();
    if (r.ok) {
      applyResult();
    }
  });

  function syncSelectedFromInput(){ var need=(modeSel.value==='4'?2:(modeSel.value==='6'?3:4)); var pr=parseRanks(input.value, need); selected=pr.ok?pr.ranks.slice():[]; }

  // Init
  generatePlayers();
  setupDropZones();
  renderStatistics();
  // Set initial state
  headline.textContent = 'ç­‰å¾…æ’å';
  explain.textContent = 'è¯·å°†ç©å®¶æ‹–åˆ°æ’åä½ç½®';
  if (winnerDisplay) winnerDisplay.textContent = 'â€”';
})();
</script>

<footer style="text-align: center; padding: 20px; margin-top: 40px; border-top: 1px solid #ddd; color: #666; font-size: 14px;">
  Made with â¤ï¸ by Xingfan Xia, Claude Opus 4.1 & GPT-5 | 
  <a href="https://github.com/xingfanxia/guandan_calc" target="_blank" style="color: #4078c0; text-decoration: none;">
    GitHub
  </a>
</footer>

</body>
</html>
